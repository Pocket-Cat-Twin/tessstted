{
  "version": 3,
  "sources": ["../../node_modules/cookie/dist/index.js", "../../node_modules/fast-decode-uri-component/index.js", "../../node_modules/memoirist/dist/bun/index.js", "../../src/index.ts", "../../src/type-system/index.ts", "../../src/type-system/format.ts", "../../src/type-system/utils.ts", "../../src/universal/utils.ts", "../../src/universal/file.ts", "../../src/error.ts", "../../src/utils.ts", "../../src/sucrose.ts", "../../src/cookies.ts", "../../src/adapter/utils.ts", "../../src/adapter/web-standard/handler.ts", "../../src/adapter/web-standard/index.ts", "../../src/compose.ts", "../../src/parse-query.ts", "../../src/trace.ts", "../../src/schema.ts", "../../node_modules/exact-mirror/dist/index.mjs", "../../src/adapter/bun/handler.ts", "../../src/adapter/bun/compose.ts", "../../src/adapter/bun/handler-native.ts", "../../src/ws/index.ts", "../../src/adapter/bun/index.ts", "../../src/universal/env.ts", "../../src/dynamic-handle.ts"],
  "sourcesContent": [
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = parse;\nexports.serialize = serialize;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parse(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const colonIdx = str.indexOf(\";\", index);\n        const endIdx = colonIdx === -1 ? len : colonIdx;\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const keyStartIdx = startIndex(str, index, eqIdx);\n        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        const key = str.slice(keyStartIdx, keyEndIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n            let valEndIdx = endIndex(str, endIdx, valStartIdx);\n            const value = dec(str.slice(valStartIdx, valEndIdx));\n            obj[key] = value;\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\nfunction startIndex(str, index, max) {\n    do {\n        const code = str.charCodeAt(index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index;\n    } while (++index < max);\n    return max;\n}\nfunction endIndex(str, index, min) {\n    while (index > min) {\n        const code = str.charCodeAt(--index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index + 1;\n    }\n    return min;\n}\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nfunction serialize(name, val, options) {\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(`argument name is invalid: ${name}`);\n    }\n    const value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${val}`);\n    }\n    let str = name + \"=\" + value;\n    if (!options)\n        return str;\n    if (options.maxAge !== undefined) {\n        if (!Number.isInteger(options.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n        }\n        str += \"; Max-Age=\" + options.maxAge;\n    }\n    if (options.domain) {\n        if (!domainValueRegExp.test(options.domain)) {\n            throw new TypeError(`option domain is invalid: ${options.domain}`);\n        }\n        str += \"; Domain=\" + options.domain;\n    }\n    if (options.path) {\n        if (!pathValueRegExp.test(options.path)) {\n            throw new TypeError(`option path is invalid: ${options.path}`);\n        }\n        str += \"; Path=\" + options.path;\n    }\n    if (options.expires) {\n        if (!isDate(options.expires) ||\n            !Number.isFinite(options.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${options.expires}`);\n        }\n        str += \"; Expires=\" + options.expires.toUTCString();\n    }\n    if (options.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (options.secure) {\n        str += \"; Secure\";\n    }\n    if (options.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (options.priority) {\n        const priority = typeof options.priority === \"string\"\n            ? options.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${options.priority}`);\n        }\n    }\n    if (options.sameSite) {\n        const sameSite = typeof options.sameSite === \"string\"\n            ? options.sameSite.toLowerCase()\n            : options.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n//# sourceMappingURL=index.js.map",
    "'use strict'\n\nvar UTF8_ACCEPT = 12\nvar UTF8_REJECT = 0\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96,\n  0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07\n]\n\nfunction decodeURIComponent (uri) {\n  var percentPosition = uri.indexOf('%')\n  if (percentPosition === -1) return uri\n\n  var length = uri.length\n  var decoded = ''\n  var last = 0\n  var codepoint = 0\n  var startOfOctets = percentPosition\n  var state = UTF8_ACCEPT\n\n  while (percentPosition > -1 && percentPosition < length) {\n    var high = hexCodeToInt(uri[percentPosition + 1], 4)\n    var low = hexCodeToInt(uri[percentPosition + 2], 0)\n    var byte = high | low\n    var type = UTF8_DATA[byte]\n    state = UTF8_DATA[256 + state + type]\n    codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])\n\n    if (state === UTF8_ACCEPT) {\n      decoded += uri.slice(last, startOfOctets)\n\n      decoded += (codepoint <= 0xFFFF)\n        ? String.fromCharCode(codepoint)\n        : String.fromCharCode(\n          (0xD7C0 + (codepoint >> 10)),\n          (0xDC00 + (codepoint & 0x3FF))\n        )\n\n      codepoint = 0\n      last = percentPosition + 3\n      percentPosition = startOfOctets = uri.indexOf('%', last)\n    } else if (state === UTF8_REJECT) {\n      return null\n    } else {\n      percentPosition += 3\n      if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue\n      return null\n    }\n  }\n\n  return decoded + uri.slice(last)\n}\n\nvar HEX = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'a': 10,\n  'A': 10,\n  'b': 11,\n  'B': 11,\n  'c': 12,\n  'C': 12,\n  'd': 13,\n  'D': 13,\n  'e': 14,\n  'E': 14,\n  'f': 15,\n  'F': 15\n}\n\nfunction hexCodeToInt (c, shift) {\n  var i = HEX[c]\n  return i === undefined ? 255 : i << shift\n}\n\nmodule.exports = decodeURIComponent\n",
    "// @bun\nvar Y=(A,b)=>{let v=b?.length?{}:null;if(v)for(let K of b)v[K.part.charCodeAt(0)]=K;return{part:A,store:null,inert:v,params:null,wildcardStore:null}},k=(A,b)=>({...A,part:b}),T=(A)=>({name:A,store:null,inert:null});class _{config;root={};history=[];deferred=[];constructor(A={}){this.config=A;if(A.lazy)this.find=this.lazyFind}static regex={static:/:.+?(?=\\/|$)/,params:/:.+?(?=\\/|$)/g,optionalParams:/(\\/:\\w+\\?)/g};lazyFind=(A,b)=>{if(!this.config.lazy)return this.find;return this.build(),this.find(A,b)};build(){if(!this.config.lazy)return;for(let[A,b,v]of this.deferred)this.add(A,b,v,{lazy:!1,ignoreHistory:!0});this.deferred=[],this.find=(A,b)=>{let v=this.root[A];if(!v)return null;return $(b,b.length,v,0)}}add(A,b,v,{ignoreError:K=!1,ignoreHistory:V=!1,lazy:U=this.config.lazy}={}){if(U)return this.find=this.lazyFind,this.deferred.push([A,b,v]),v;if(typeof b!==\"string\")throw new TypeError(\"Route path must be a string\");if(b===\"\")b=\"/\";else if(b[0]!==\"/\")b=`/${b}`;let J=b[b.length-1]===\"*\",F=b.match(_.regex.optionalParams);if(F){let S=b.replaceAll(\"?\",\"\");this.add(A,S,v,{ignoreError:K,ignoreHistory:V,lazy:U});for(let D=0;D<F.length;D++){let B=b.replace(F[D],\"\");this.add(A,B,v,{ignoreError:!0,ignoreHistory:V,lazy:U})}return v}if(F)b=b.replaceAll(\"?\",\"\");if(this.history.find(([S,D,B])=>S===A&&D===b))return v;if(J||F&&b.charCodeAt(b.length-1)===63)b=b.slice(0,-1);if(!V)this.history.push([A,b,v]);let G=b.split(_.regex.static),X=b.match(_.regex.params)||[];if(G[G.length-1]===\"\")G.pop();let q;if(!this.root[A])q=this.root[A]=Y(\"/\");else q=this.root[A];let O=0;for(let S=0;S<G.length;++S){let D=G[S];if(S>0){let B=X[O++].slice(1);if(q.params===null)q.params=T(B);else if(q.params.name!==B)if(K)return v;else throw new Error(`Cannot create route \"${b}\" with parameter \"${B}\" because a route already exists with a different parameter name (\"${q.params.name}\") in the same location`);let Q=q.params;if(Q.inert===null){q=Q.inert=Y(D);continue}q=Q.inert}for(let B=0;;){if(B===D.length){if(B<q.part.length){let Q=k(q,q.part.slice(B));Object.assign(q,Y(D,[Q]))}break}if(B===q.part.length){if(q.inert===null)q.inert={};let Q=q.inert[D.charCodeAt(B)];if(Q){q=Q,D=D.slice(B),B=0;continue}let Z=Y(D.slice(B));q.inert[D.charCodeAt(B)]=Z,q=Z;break}if(D[B]!==q.part[B]){let Q=k(q,q.part.slice(B)),Z=Y(D.slice(B));Object.assign(q,Y(q.part.slice(0,B),[Q,Z])),q=Z;break}++B}}if(O<X.length){let D=X[O].slice(1);if(q.params===null)q.params=T(D);else if(q.params.name!==D)if(K)return v;else throw new Error(`Cannot create route \"${b}\" with parameter \"${D}\" because a route already exists with a different parameter name (\"${q.params.name}\") in the same location`);if(q.params.store===null)q.params.store=v;return q.params.store}if(J){if(q.wildcardStore===null)q.wildcardStore=v;return q.wildcardStore}if(q.store===null)q.store=v;return q.store}find(A,b){let v=this.root[A];if(!v)return null;return $(b,b.length,v,0)}}var $=(A,b,v,K)=>{let V=v.part,U=V.length,J=K+U;if(U>1){if(J>b)return null;if(U<15){for(let F=1,G=K+1;F<U;++F,++G)if(V.charCodeAt(F)!==A.charCodeAt(G))return null}else if(A.slice(K,J)!==V)return null}if(J===b){if(v.store!==null)return{store:v.store,params:{}};if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":\"\"}};return null}if(v.inert!==null){let F=v.inert[A.charCodeAt(J)];if(F!==void 0){let G=$(A,b,F,J);if(G!==null)return G}}if(v.params!==null){let{store:F,name:G,inert:X}=v.params,q=A.indexOf(\"/\",J);if(q!==J){if(q===-1||q>=b){if(F!==null){let O={};return O[G]=A.substring(J,b),{store:F,params:O}}}else if(X!==null){let O=$(A,b,X,q);if(O!==null)return O.params[G]=A.substring(J,q),O}}}if(v.wildcardStore!==null)return{store:v.wildcardStore,params:{\"*\":A.substring(J,b)}};return null},w=_;export{w as default,_ as Memoirist};\n\n//# debugId=AA98D63C1584F1E864756E2164756E21\n",
    "import { Memoirist } from 'memoirist'\nimport {\n\tKind,\n\ttype TObject,\n\ttype Static,\n\ttype TSchema,\n\ttype TModule,\n\ttype TRef,\n\ttype TProperties\n} from '@sinclair/typebox'\n\nimport type { Context } from './context'\n\nimport { t } from './type-system'\nimport {\n\tclearSucroseCache,\n\tmergeInference,\n\tsucrose,\n\ttype Sucrose\n} from './sucrose'\n\nimport type { WSLocalHook } from './ws/types'\n\nimport { BunAdapter } from './adapter/bun/index'\nimport { WebStandardAdapter } from './adapter/web-standard/index'\nimport type { ElysiaAdapter } from './adapter/types'\n\nimport { env } from './universal/env'\nimport type { ListenCallback, Serve, Server } from './universal/server'\n\nimport {\n\tcloneInference,\n\tdeduplicateChecksum,\n\tfnToContainer,\n\tgetLoosePath,\n\tlocalHookToLifeCycleStore,\n\tmergeDeep,\n\tmergeSchemaValidator,\n\tPromiseGroup,\n\tpromoteEvent,\n\tisNotEmpty,\n\tencodePath,\n\tlifeCycleToArray,\n\tsupportPerMethodInlineHandler\n} from './utils'\n\nimport {\n\tcoercePrimitiveRoot,\n\tstringToStructureCoercions,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tgetCookieValidator,\n\tElysiaTypeCheck\n} from './schema'\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\n\nimport { createTracer } from './trace'\n\nimport {\n\tmergeHook,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasHookType,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tcreateMacroManager\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tERROR_CODE,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError,\n\tElysiaCustomStatusResponse\n} from './error'\n\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tAnyLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tPrettify2,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tMaybeArray,\n\tGracefulHandler,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tMacroToProperty,\n\tTransformHandler,\n\tMetadataBase,\n\tRouteBase,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tInlineHandler,\n\tHookContainer,\n\tLifeCycleType,\n\tMacroQueue,\n\tEphemeralType,\n\tExcludeElysiaResponse,\n\tModelValidator,\n\tBaseMacroFn,\n\tContextAppendType,\n\tReconcile,\n\tAfterResponseHandler,\n\tHigherOrderFunction,\n\tResolvePath,\n\tJoinPath,\n\tValidatorLayer,\n\tMergeElysiaInstances,\n\tHookMacroFn,\n\tResolveHandler,\n\tResolveResolutions,\n\tUnwrapTypeModule,\n\tMacroToContext,\n\tStandaloneValidator,\n\tGuardSchemaType,\n\tOr,\n\tPrettifySchema,\n\tMergeStandaloneSchema,\n\tIsNever,\n\tDocumentDecoration,\n\tAfterHandler\n} from './types'\n\nexport type AnyElysia = Elysia<any, any, any, any, any, any, any>\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(3000)\n * ```\n */\nexport default class Elysia<\n\tconst in out BasePath extends string = '',\n\tconst in out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tconst in out Definitions extends DefinitionBase = {\n\t\ttypebox: {}\n\t\terror: {}\n\t},\n\tconst in out Metadata extends MetadataBase = {\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t\tmacro: {}\n\t\tmacroFn: {}\n\t\tparser: {}\n\t},\n\tconst out Routes extends RouteBase = {},\n\t// ? scoped\n\tconst in out Ephemeral extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t},\n\t// ? local\n\tconst in out Volatile extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t\tstandaloneSchema: {}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath>\n\n\tserver: Server | null = null\n\tprivate dependencies: { [key in string]: Checksum[] } = {}\n\n\t'~Prefix' = '' as BasePath\n\t'~Singleton' = null as unknown as Singleton\n\t'~Definitions' = null as unknown as Definitions\n\t'~Metadata' = null as unknown as Metadata\n\t'~Ephemeral' = null as unknown as Ephemeral\n\t'~Volatile' = null as unknown as Volatile\n\t'~Routes' = null as unknown as Routes\n\n\tprotected singleton = {\n\t\tdecorator: {},\n\t\tstore: {},\n\t\tderive: {},\n\t\tresolve: {}\n\t} as SingletonBase\n\n\tget store(): Singleton['store'] {\n\t\treturn this.singleton.store\n\t}\n\n\tget decorator(): Singleton['decorator'] {\n\t\treturn this.singleton.decorator\n\t}\n\n\tprotected definitions = {\n\t\ttypebox: t.Module({}),\n\t\ttype: {} as Record<string, TSchema>,\n\t\terror: {} as Record<string, Error>\n\t}\n\n\tprotected extender = {\n\t\tmacros: <MacroQueue[]>[],\n\t\thigherOrderFunctions: <HookContainer<HigherOrderFunction>[]>[]\n\t}\n\n\tprotected validator: ValidatorLayer = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null,\n\t\tgetCandidate() {\n\t\t\tif (!this.global && !this.scoped && !this.local)\n\t\t\t\treturn {\n\t\t\t\t\tbody: undefined,\n\t\t\t\t\theaders: undefined,\n\t\t\t\t\tparams: undefined,\n\t\t\t\t\tquery: undefined,\n\t\t\t\t\tcookie: undefined,\n\t\t\t\t\tresponse: undefined\n\t\t\t\t}\n\n\t\t\treturn mergeSchemaValidator(\n\t\t\t\tmergeSchemaValidator(this.global, this.scoped),\n\t\t\t\tthis.local\n\t\t\t)\n\t\t}\n\t}\n\n\tprotected standaloneValidator: StandaloneValidator = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null\n\t}\n\n\tevent: Partial<LifeCycleStore> = {}\n\n\tprotected telemetry:\n\t\t| undefined\n\t\t| {\n\t\t\t\tstack: string | undefined\n\t\t  }\n\n\trouter = {\n\t\t'~http': undefined as\n\t\t\t| Memoirist<{\n\t\t\t\t\tcompile: Function\n\t\t\t\t\thandler?: ComposedHandler\n\t\t\t  }>\n\t\t\t| undefined,\n\t\tget http() {\n\t\t\tif (!this['~http']) this['~http'] = new Memoirist({ lazy: true })\n\n\t\t\treturn this['~http']\n\t\t},\n\t\t'~dynamic': undefined as Memoirist<DynamicHandler> | undefined,\n\t\t// Use in non-AOT mode\n\t\tget dynamic() {\n\t\t\tif (!this['~dynamic']) this['~dynamic'] = new Memoirist()\n\n\t\t\treturn this['~dynamic']\n\t\t},\n\t\t// Static Router\n\t\tstatic: {} as { [path in string]: { [method in string]: number } },\n\t\t// Native Static Response\n\t\tresponse: {} as {\n\t\t\t[path: string]:\n\t\t\t\t| MaybePromise<Response | undefined>\n\t\t\t\t| { [method: string]: MaybePromise<Response | undefined> }\n\t\t},\n\t\thistory: [] as InternalRoute[]\n\t}\n\n\tprotected routeTree: Record<string, number> = {}\n\n\tget routes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalRoutes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalDefinitions() {\n\t\treturn this.definitions\n\t}\n\n\tprotected inference: Sucrose.Inference = {\n\t\tbody: false,\n\t\tcookie: false,\n\t\theaders: false,\n\t\tquery: false,\n\t\tset: false,\n\t\tserver: false,\n\t\tpath: false,\n\t\troute: false,\n\t\turl: false\n\t}\n\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\n\tprivate getParent(): Elysia | null {\n\t\treturn null\n\t}\n\n\t'~parser': { [K in string]: BodyHandler<any, any> } = {}\n\n\tprivate _promisedModules: PromiseGroup | undefined\n\tprivate get promisedModules() {\n\t\tif (!this._promisedModules)\n\t\t\tthis._promisedModules = new PromiseGroup(console.error, () => {\n\t\t\t\t// this.compile()\n\t\t\t})\n\n\t\treturn this._promisedModules\n\t}\n\n\tconstructor(config: ElysiaConfig<BasePath> = {}) {\n\t\tif (config.tags) {\n\t\t\tif (!config.detail)\n\t\t\t\tconfig.detail = {\n\t\t\t\t\ttags: config.tags\n\t\t\t\t}\n\t\t\telse config.detail.tags = config.tags\n\t\t}\n\n\t\tthis.config = {\n\t\t\tprefix: '' as any,\n\t\t\taot: env.ELYSIA_AOT !== 'false',\n\t\t\tnativeStaticResponse: true,\n\t\t\tsystemRouter: true,\n\t\t\tencodeSchema: true,\n\t\t\tnormalize: true,\n\t\t\t...config,\n\t\t\tcookie: {\n\t\t\t\tpath: '/',\n\t\t\t\t...config?.cookie\n\t\t\t},\n\t\t\texperimental: config?.experimental ?? {},\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t}\n\n\t\tthis['~adapter'] =\n\t\t\tconfig.adapter ??\n\t\t\t(typeof Bun !== 'undefined' ? BunAdapter : WebStandardAdapter)\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.telemetry = {\n\t\t\t\tstack: new Error().stack\n\t\t\t}\n\t}\n\n\t'~adapter': ElysiaAdapter\n\n\tenv(model: TObject<any>, _env = env) {\n\t\tconst validator = getSchemaValidator(model, {\n\t\t\tmodules: this.definitions.typebox,\n\t\t\tdynamic: true,\n\t\t\tadditionalProperties: true,\n\t\t\tcoerce: true,\n\t\t\tsanitize: () => this.config.sanitize\n\t\t})\n\n\t\tif (validator.Check(_env) === false) {\n\t\t\tconst error = new ValidationError('env', model, _env)\n\n\t\t\tthrow new Error(error.all.map((x) => x.summary).join('\\n'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\t * @version 1.1.0\n\t *\n\t * ! Do not use unless you know exactly what you are doing\n\t * ? Add Higher order function to Elysia.fetch\n\t */\n\twrap(fn: HigherOrderFunction) {\n\t\tthis.extender.higherOrderFunctions.push({\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: fn.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn\n\t\t})\n\n\t\treturn this\n\t}\n\n\tprivate applyMacro(localHook: AnyLocalHook) {\n\t\tif (this.extender.macros.length) {\n\t\t\tconst manage = createMacroManager({\n\t\t\t\tglobalHook: this.event,\n\t\t\t\tlocalHook\n\t\t\t})\n\n\t\t\tconst manager: MacroManager = {\n\t\t\t\tevents: {\n\t\t\t\t\tglobal: this.event,\n\t\t\t\t\tlocal: localHook\n\t\t\t\t},\n\t\t\t\tget onParse() {\n\t\t\t\t\treturn manage('parse') as any\n\t\t\t\t},\n\t\t\t\tget onTransform() {\n\t\t\t\t\treturn manage('transform') as any\n\t\t\t\t},\n\t\t\t\tget onBeforeHandle() {\n\t\t\t\t\treturn manage('beforeHandle') as any\n\t\t\t\t},\n\t\t\t\tget onAfterHandle() {\n\t\t\t\t\treturn manage('afterHandle') as any\n\t\t\t\t},\n\t\t\t\tget mapResponse() {\n\t\t\t\t\treturn manage('mapResponse') as any\n\t\t\t\t},\n\t\t\t\tget onAfterResponse() {\n\t\t\t\t\treturn manage('afterResponse') as any\n\t\t\t\t},\n\t\t\t\tget onError() {\n\t\t\t\t\treturn manage('error') as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const macro of this.extender.macros)\n\t\t\t\ttraceBackMacro(macro.fn(manager), localHook, manage)\n\t\t}\n\t}\n\n\tget models(): {\n\t\t[K in keyof Definitions['typebox']]: ModelValidator<\n\t\t\tDefinitions['typebox'][K]\n\t\t>\n\t} & {\n\t\tmodules: TModule<Definitions['typebox']>\n\t} {\n\t\tconst models: Record<string, ElysiaTypeCheck<TSchema>> = {}\n\n\t\tfor (const name of Object.keys(this.definitions.type))\n\t\t\tmodels[name] = getSchemaValidator(\n\t\t\t\tthis.definitions.typebox.Import(name as never)\n\t\t\t)\n\n\t\t// @ts-expect-error\n\t\tmodels.modules = this.definitions.typebox\n\n\t\treturn models as any\n\t}\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: AnyLocalHook,\n\t\toptions?: {\n\t\t\tallowMeta?: boolean\n\t\t\tskipPrefix?: boolean\n\t\t},\n\t\tstandaloneValidators?: InputSchema<string>[]\n\t) {\n\t\tconst skipPrefix = options?.skipPrefix ?? false\n\t\tconst allowMeta = options?.allowMeta ?? false\n\n\t\tlocalHook ??= {}\n\n\t\tif (standaloneValidators === undefined) {\n\t\t\tstandaloneValidators = []\n\n\t\t\tif (this.standaloneValidator.local)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.local\n\t\t\t\t)\n\n\t\t\tif (this.standaloneValidator.scoped)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.scoped\n\t\t\t\t)\n\n\t\t\tif (this.standaloneValidator.global)\n\t\t\t\tstandaloneValidators = standaloneValidators.concat(\n\t\t\t\t\tthis.standaloneValidator.global\n\t\t\t\t)\n\t\t}\n\n\t\tif (path !== '' && path.charCodeAt(0) !== 47) path = '/' + path\n\t\tif (this.config.prefix && !skipPrefix) path = this.config.prefix + path\n\n\t\tif (localHook?.type)\n\t\t\tswitch (localHook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst instanceValidator = this.validator.getCandidate()\n\n\t\tconst cloned = {\n\t\t\tbody: localHook?.body ?? (instanceValidator?.body as any),\n\t\t\theaders: localHook?.headers ?? (instanceValidator?.headers as any),\n\t\t\tparams: localHook?.params ?? (instanceValidator?.params as any),\n\t\t\tquery: localHook?.query ?? (instanceValidator?.query as any),\n\t\t\tcookie: localHook?.cookie ?? (instanceValidator?.cookie as any),\n\t\t\tresponse:\n\t\t\t\tlocalHook?.response ?? (instanceValidator?.response as any)\n\t\t}\n\n\t\tconst shouldPrecompile =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.compose === true)\n\n\t\tconst createValidator = () => {\n\t\t\tconst models = this.definitions.type\n\t\t\tconst dynamic = !this.config.aot\n\n\t\t\tconst normalize = this.config.normalize\n\t\t\tconst modules = this.definitions.typebox\n\n\t\t\tconst sanitize = () => this.config.sanitize\n\n\t\t\tconst cookieValidator = () => {\n\t\t\t\tif (cloned.cookie || standaloneValidators.find((x) => x.cookie))\n\t\t\t\t\treturn getCookieValidator({\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\tvalidator: cloned.cookie,\n\t\t\t\t\t\tdefaultConfig: this.config.cookie,\n\t\t\t\t\t\tconfig: cloned.cookie?.config ?? {},\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tmodels,\n\t\t\t\t\t\tvalidators: standaloneValidators.map((x) => x.cookie),\n\t\t\t\t\t\tsanitize\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn shouldPrecompile\n\t\t\t\t? {\n\t\t\t\t\t\tbody: getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map((x) => x.body),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\theaders: getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: true,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.headers\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams: getSchemaValidator(cloned.params, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.params\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tquery: getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions(),\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.query\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tcookie: cookieValidator(),\n\t\t\t\t\t\tresponse: getResponseSchemaValidator(cloned.response, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t(x) => x.response\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t: ({\n\t\t\t\t\t\tcreateBody() {\n\t\t\t\t\t\t\tif (this.body) return this.body\n\n\t\t\t\t\t\t\treturn (this.body = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.body,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.body\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateHeaders() {\n\t\t\t\t\t\t\tif (this.headers) return this.headers\n\n\t\t\t\t\t\t\treturn (this.headers = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.headers,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tadditionalProperties: !normalize,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.headers\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateParams() {\n\t\t\t\t\t\t\tif (this.params) return this.params\n\n\t\t\t\t\t\t\treturn (this.params = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.params,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.params\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateQuery() {\n\t\t\t\t\t\t\tif (this.query) return this.query\n\n\t\t\t\t\t\t\treturn (this.query = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.query,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions(),\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.query\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateCookie() {\n\t\t\t\t\t\t\tif (this.cookie) return this.cookie\n\n\t\t\t\t\t\t\treturn (this.cookie = cookieValidator())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateResponse() {\n\t\t\t\t\t\t\tif (this.response) return this.response\n\n\t\t\t\t\t\t\treturn (this.response = getResponseSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.response,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\t\tvalidators: standaloneValidators.map(\n\t\t\t\t\t\t\t\t\t\t(x) => x.response\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tsanitize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any)\n\t\t}\n\n\t\tif (\n\t\t\tinstanceValidator.body ||\n\t\t\tinstanceValidator.cookie ||\n\t\t\tinstanceValidator.headers ||\n\t\t\tinstanceValidator.params ||\n\t\t\tinstanceValidator.query ||\n\t\t\tinstanceValidator.response\n\t\t)\n\t\t\tlocalHook = mergeHook(localHook, instanceValidator)\n\n\t\tif (localHook.tags) {\n\t\t\tif (!localHook.detail)\n\t\t\t\tlocalHook.detail = {\n\t\t\t\t\ttags: localHook.tags\n\t\t\t\t}\n\t\t\telse localHook.detail.tags = localHook.tags\n\t\t}\n\n\t\tif (isNotEmpty(this.config.detail))\n\t\t\tlocalHook.detail = mergeDeep(\n\t\t\t\tObject.assign({}, this.config.detail!),\n\t\t\t\tlocalHook.detail\n\t\t\t)\n\n\t\tthis.applyMacro(localHook)\n\n\t\tconst hooks = isNotEmpty(this.event)\n\t\t\t? mergeHook(this.event, localHookToLifeCycleStore(localHook))\n\t\t\t: lifeCycleToArray(localHookToLifeCycleStore(localHook))\n\n\t\tif (this.config.aot === false) {\n\t\t\tconst validator = createValidator()\n\n\t\t\tthis.router.dynamic.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\thandle,\n\t\t\t\troute: path\n\t\t\t})\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.dynamic.add(method, encoded, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\n\t\t\t\tconst encoded = encodePath(loosePath)\n\t\t\t\tif (loosePath !== encoded)\n\t\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\t\thandle,\n\t\t\t\t\t\troute: path\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.router.history.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler: handle,\n\t\t\t\tcompile: undefined as any,\n\t\t\t\thooks,\n\t\t\t\tstandaloneValidators\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tconst adapter = this['~adapter'].handler\n\n\t\tconst nativeStaticHandler =\n\t\t\ttypeof handle !== 'function'\n\t\t\t\t? () => {\n\t\t\t\t\t\tconst fn = adapter.createNativeStaticHandler?.(\n\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\thooks,\n\t\t\t\t\t\t\tthis.setHeaders\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn fn instanceof Promise\n\t\t\t\t\t\t\t? fn.then((fn) => {\n\t\t\t\t\t\t\t\t\tif (fn) return fn\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: fn?.()\n\t\t\t\t\t}\n\t\t\t\t: undefined\n\n\t\tconst useNativeStaticResponse =\n\t\t\tthis.config.nativeStaticResponse === true\n\n\t\tconst addResponsePath = (path: string) => {\n\t\t\tif (!useNativeStaticResponse || !nativeStaticHandler) return\n\n\t\t\tif (supportPerMethodInlineHandler) {\n\t\t\t\tif (this.router.response[path])\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tthis.router.response[path]![method] = nativeStaticHandler()\n\t\t\t\telse\n\t\t\t\t\tthis.router.response[path] = {\n\t\t\t\t\t\t[method]: nativeStaticHandler()\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.router.response[path] = nativeStaticHandler()\n\t\t\t}\n\t\t}\n\n\t\taddResponsePath(path)\n\n\t\tlet _compiled: ComposedHandler\n\t\tconst compile = () => {\n\t\t\tif (_compiled) return _compiled\n\n\t\t\treturn (_compiled = composeHandler({\n\t\t\t\tapp: this,\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\thooks,\n\t\t\t\tvalidator: createValidator(),\n\t\t\t\thandler:\n\t\t\t\t\ttypeof handle !== 'function' &&\n\t\t\t\t\ttypeof adapter.createStaticHandler !== 'function'\n\t\t\t\t\t\t? () => handle\n\t\t\t\t\t\t: handle,\n\t\t\t\tallowMeta,\n\t\t\t\tinference: this.inference\n\t\t\t}))\n\t\t}\n\n\t\tlet oldIndex: number | undefined\n\t\tif (`${method}_${path}` in this.routeTree)\n\t\t\tfor (let i = 0; i < this.router.history.length; i++) {\n\t\t\t\tconst route = this.router.history[i]\n\t\t\t\tif (route.path === path && route.method === method) {\n\t\t\t\t\toldIndex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\telse this.routeTree[`${method}_${path}`] = this.router.history.length\n\n\t\tconst index = oldIndex ?? this.router.history.length\n\n\t\tconst mainHandler = shouldPrecompile\n\t\t\t? compile()\n\t\t\t: (ctx: Context) =>\n\t\t\t\t\t(\n\t\t\t\t\t\t(this.router.history[index].composed =\n\t\t\t\t\t\t\tcompile!()) as ComposedHandler\n\t\t\t\t\t)(ctx)\n\n\t\tif (oldIndex !== undefined)\n\t\t\tthis.router.history[oldIndex] = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\tcomposed: mainHandler,\n\t\t\t\t\tcompile: compile!,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\thooks\n\t\t\t\t},\n\t\t\t\tstandaloneValidators.length\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t\tlocalHook.webSocket\n\t\t\t\t\t? { websocket: localHook.websocket as any }\n\t\t\t\t\t: undefined\n\t\t\t)\n\t\telse\n\t\t\tthis.router.history.push(\n\t\t\t\tObject.assign(\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tcomposed: mainHandler,\n\t\t\t\t\t\tcompile: compile!,\n\t\t\t\t\t\thandler: handle,\n\t\t\t\t\t\thooks\n\t\t\t\t\t},\n\t\t\t\t\tstandaloneValidators.length\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined,\n\t\t\t\t\tlocalHook.webSocket\n\t\t\t\t\t\t? { websocket: localHook.websocket as any }\n\t\t\t\t\t\t: undefined\n\t\t\t\t)\n\t\t\t)\n\n\t\tconst handler = {\n\t\t\thandler: shouldPrecompile ? mainHandler : undefined,\n\t\t\tcompile() {\n\t\t\t\treturn (this.handler = compile!())\n\t\t\t}\n\t\t}\n\n\t\tconst staticRouter = this.router.static\n\t\tconst isStaticPath =\n\t\t\tpath.indexOf(':') === -1 && path.indexOf('*') === -1\n\n\t\tif (method === 'WS') {\n\t\t\tif (isStaticPath) {\n\t\t\t\tif (path in staticRouter) staticRouter[path][method] = index\n\t\t\t\telse\n\t\t\t\t\tstaticRouter[path] = {\n\t\t\t\t\t\t[method]: index\n\t\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.router.http.add('WS', path, handler)\n\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.http.add('WS', getLoosePath(path), handler)\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) this.router.http.add('WS', encoded, handler)\n\n\t\t\t// Static path doesn't need encode as it's done in compilation process\n\n\t\t\treturn\n\t\t}\n\n\t\tif (isStaticPath) {\n\t\t\tif (path in staticRouter) staticRouter[path][method] = index\n\t\t\telse\n\t\t\t\tstaticRouter[path] = {\n\t\t\t\t\t[method]: index\n\t\t\t\t} as const\n\n\t\t\tif (!this.config.strictPath) addResponsePath(getLoosePath(path))\n\n\t\t\t// Static path doesn't need encode as it's done in compilation process\n\t\t} else {\n\t\t\tthis.router.http.add(method, path, handler)\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\n\t\t\t\taddResponsePath(loosePath)\n\t\t\t\tthis.router.http.add(method, loosePath, handler)\n\t\t\t}\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.http.add(method, encoded, handler)\n\n\t\t\t\taddResponsePath(encoded)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ server }) => {\n\t *         console.log(\"Running at ${server?.url}:${server?.port}\")\n\t *     })\n\t *     .listen(3000)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: {}\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t) {\n\t\tthis.on('request', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema>(\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema, const Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonParse<const Parsers extends keyof Metadata['parser']>(\n\t\tparser: Parsers\n\t): this\n\n\tonParse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function> | string,\n\t\thandler?: MaybeArray<Function>\n\t): unknown {\n\t\tif (!handler) {\n\t\t\tif (typeof options === 'string')\n\t\t\t\treturn this.on('parse', this['~parser'][options] as any)\n\n\t\t\treturn this.on('parse', options as any)\n\t\t}\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'parse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tparser<\n\t\tconst Parser extends string,\n\t\tconst Schema extends RouteSchema,\n\t\tconst Handler extends BodyHandler<\n\t\t\tMergeSchema<\n\t\t\t\tSchema,\n\t\t\t\tMergeSchema<\n\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t>,\n\t\t\t\tBasePath\n\t\t\t> &\n\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t{\n\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\tstore: Singleton['store']\n\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\tVolatile['derive']\n\t\t\t\tresolve: {}\n\t\t\t}\n\t\t>\n\t>(\n\t\tname: Parser,\n\t\tparser: Handler\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser'] & { [K in Parser]: Handler }\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis['~parser'][name] = parser as any\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonTransform(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('transform', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'transform',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t\t&\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t},\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tresolve(\n\t\toptionsOrResolve: { as?: LifeCycleType } | Function,\n\t\tresolve?: Function\n\t) {\n\t\tif (!resolve) {\n\t\t\tresolve = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: resolve!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapResolve(\n\t\toptionsOrResolve: Function | { as?: LifeCycleType },\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapResolve',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\tonBeforeHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('beforeHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'beforeHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema, Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tmapResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('mapResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'mapResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonAfterResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t * \t   })\n\t * ```\n\t */\n\n\tonAfterResponse<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t&\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) {\n\t\t\thandler = options as MaybeArray<Function>\n\t\t\toptions = { as: 'local' }\n\t\t}\n\n\t\tif (!Array.isArray(handler)) handler = [handler] as Function[]\n\n\t\tfor (const fn of handler)\n\t\t\tthis.on(\n\t\t\t\toptions as { as?: LifeCycleType },\n\t\t\t\t'trace',\n\t\t\t\tcreateTracer(fn as any) as any\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): AnyElysia {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code as any\n\n\t\t\tthis.definitions.error[code] = error as any\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Scope extends LifeCycleType\n\t>(\n\t\toptions: { as?: Scope },\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t}\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive']\n\t\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\t\tEphemeral['resolve']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: Singleton,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t},\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? Ephemeral\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('error', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'error',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Event,\n\t\thandlers: MaybeArray<\n\t\t\tExtract<LifeCycleStore[Event], HookContainer[]>[0]['fn']\n\t\t>\n\t): this\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<const Event extends keyof LifeCycleStore>(\n\t\toptions: { as?: LifeCycleType },\n\t\ttype: Event,\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t): this\n\n\ton(\n\t\toptionsOrType: { as?: LifeCycleType } | string,\n\t\ttypeOrHandlers: MaybeArray<Function | HookContainer> | string,\n\t\thandlers?: MaybeArray<Function | HookContainer>\n\t) {\n\t\tlet type: keyof LifeCycleStore\n\n\t\tswitch (typeof optionsOrType) {\n\t\t\tcase 'string':\n\t\t\t\ttype = optionsOrType as any\n\t\t\t\thandlers = typeOrHandlers as any\n\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\ttype = typeOrHandlers as any\n\n\t\t\t\tif (\n\t\t\t\t\t!Array.isArray(typeOrHandlers) &&\n\t\t\t\t\ttypeof typeOrHandlers === 'object'\n\t\t\t\t)\n\t\t\t\t\thandlers = typeOrHandlers\n\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (Array.isArray(handlers)) handlers = fnToContainer(handlers)\n\t\telse {\n\t\t\tif (typeof handlers === 'function')\n\t\t\t\thandlers = [\n\t\t\t\t\t{\n\t\t\t\t\t\tfn: handlers\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\telse handlers = [handlers!]\n\t\t}\n\n\t\tconst handles = handlers as HookContainer[]\n\n\t\tfor (const handle of handles) {\n\t\t\thandle.scope =\n\t\t\t\ttypeof optionsOrType === 'string'\n\t\t\t\t\t? 'local'\n\t\t\t\t\t: (optionsOrType?.as ?? 'local')\n\n\t\t\t// @ts-expect-error\n\t\t\tif (type === 'resolve' || type === 'derive') handle.subType = type\n\t\t}\n\n\t\tif (type !== 'trace')\n\t\t\tthis.inference = sucrose(\n\t\t\t\t{\n\t\t\t\t\t[type]: handles.map((x) => x.fn)\n\t\t\t\t},\n\t\t\t\tthis.inference\n\t\t\t)\n\n\t\tfor (const handle of handles) {\n\t\t\tconst fn = asHookType(handle, 'global', { skipIfHasType: true })\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start ??= []\n\t\t\t\t\tthis.event.start.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request ??= []\n\t\t\t\t\tthis.event.request.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse ??= []\n\t\t\t\t\tthis.event.parse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcase 'derive':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'derive') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\t// eslint-disable-next-line sonarjs/no-duplicated-branches\n\t\t\t\tcase 'resolve':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'resolve') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle ??= []\n\t\t\t\t\tthis.event.afterHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse ??= []\n\t\t\t\t\tthis.event.mapResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterResponse':\n\t\t\t\t\tthis.event.afterResponse ??= []\n\t\t\t\t\tthis.event.afterResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace ??= []\n\t\t\t\t\tthis.event.trace.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error ??= []\n\t\t\t\t\tthis.event.error.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop ??= []\n\t\t\t\t\tthis.event.stop.push(fn as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tas(type: 'global'): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Ephemeral['derive'] & Volatile['derive']\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve']\n\t\t\t>\n\t\t},\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: MergeSchema<\n\t\t\t\tMergeSchema<Volatile['schema'], Ephemeral['schema']>,\n\t\t\t\tMetadata['schema']\n\t\t\t>\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t}\n\t>\n\n\tas(type: 'scoped'): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\t{\n\t\t\tderive: Prettify<Ephemeral['derive'] & Volatile['derive']>\n\t\t\tresolve: Prettify<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\tschema: MergeSchema<Volatile['schema'], Ephemeral['schema']>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] & Ephemeral['standaloneSchema']\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t\tstandaloneSchema: {}\n\t\t}\n\t>\n\n\tas(type: 'global' | 'scoped') {\n\t\tpromoteEvent(this.event.parse, type)\n\t\tpromoteEvent(this.event.transform, type)\n\t\tpromoteEvent(this.event.beforeHandle, type)\n\t\tpromoteEvent(this.event.afterHandle, type)\n\t\tpromoteEvent(this.event.mapResponse, type)\n\t\tpromoteEvent(this.event.afterResponse, type)\n\t\tpromoteEvent(this.event.trace, type)\n\t\tpromoteEvent(this.event.error, type)\n\n\t\tif (type === 'scoped') {\n\t\t\tthis.validator.scoped = mergeSchemaValidator(\n\t\t\t\tthis.validator.scoped,\n\t\t\t\tthis.validator.local\n\t\t\t)\n\t\t\tthis.validator.local = null\n\n\t\t\tif (this.standaloneValidator.local !== null) {\n\t\t\t\tthis.standaloneValidator.scoped ||= []\n\t\t\t\tthis.standaloneValidator.scoped.push(\n\t\t\t\t\t...this.standaloneValidator.local\n\t\t\t\t)\n\t\t\t\tthis.standaloneValidator.local = null\n\t\t\t}\n\t\t} else if (type === 'global') {\n\t\t\tthis.validator.global = mergeSchemaValidator(\n\t\t\t\tthis.validator.global,\n\t\t\t\tmergeSchemaValidator(\n\t\t\t\t\tthis.validator.scoped,\n\t\t\t\t\tthis.validator.local\n\t\t\t\t) as SchemaValidator\n\t\t\t) as SchemaValidator\n\n\t\t\tthis.validator.scoped = null\n\t\t\tthis.validator.local = null\n\n\t\t\tif (this.standaloneValidator.local !== null) {\n\t\t\t\tthis.standaloneValidator.scoped ||= []\n\t\t\t\tthis.standaloneValidator.scoped.push(\n\t\t\t\t\t...this.standaloneValidator.local\n\t\t\t\t)\n\t\t\t\tthis.standaloneValidator.local = null\n\t\t\t}\n\t\t\tif (this.standaloneValidator.scoped !== null) {\n\t\t\t\tthis.standaloneValidator.global ||= []\n\t\t\t\tthis.standaloneValidator.global.push(\n\t\t\t\t\t...this.standaloneValidator.scoped\n\t\t\t\t)\n\t\t\t\tthis.standaloneValidator.scoped = null\n\t\t\t}\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tgroup<const Prefix extends string, const NewElysia extends AnyElysia>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: MergeSchema<\n\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t\t\t\t>,\n\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t>\n\t\t\t\t\tstandaloneSchema: Prettify<\n\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t\t\t\t> &\n\t\t\t\t\t\t\tMetadata['standaloneSchema']\n\t\t\t\t\t>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Input extends InputSchema<keyof Definitions['typebox'] & string>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tInput,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t>,\n\t\t\tMetadata['schema']\n\t\t> & Metadata['standaloneSchema'],\n\t\tconst Resolutions extends MaybeArray<\n\t\t\tResolveHandler<\n\t\t\t\tSchema,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tInput,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tkeyof Metadata['parser']\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] &\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\tResolveResolutions<Resolutions>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes & NewElysia['~Routes'],\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun: AnyLocalHook | ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.getServer = () => this.getServer()\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\t\tinstance['~parser'] = this['~parser']\n\t\tinstance.standaloneValidator = {\n\t\t\tlocal: [...(this.standaloneValidator.local ?? [])],\n\t\t\tscoped: [...(this.standaloneValidator.scoped ?? [])],\n\t\t\tglobal: [...(this.standaloneValidator.global ?? [])]\n\t\t}\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...((sandbox.event.request || []) as any)\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...((sandbox.event.mapResponse || []) as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks, standaloneValidators }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as AnyLocalHook\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...(localHook || {}),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error ?? []),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error ?? [])\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error ?? [])\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>,\n\t\tconst GuardType extends GuardSchemaType,\n\t\tconst AsType extends LifeCycleType\n\t>(\n\t\thook: {\n\t\t\t/**\n\t\t\t * @default 'override'\n\t\t\t */\n\t\t\tas?: AsType\n\t\t\t/**\n\t\t\t * @default 'standalone'\n\t\t\t * @since 1.3.0\n\t\t\t */\n\t\t\tschema?: GuardType\n\t\t} & LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Or<\n\t\tGuardSchemaType extends GuardType ? true : false,\n\t\tGuardType extends 'override' ? true : false\n\t> extends true\n\t\t? Or<\n\t\t\t\tLifeCycleType extends AsType ? true : false,\n\t\t\t\tAsType extends 'local' ? true : false\n\t\t\t> extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t: AsType extends 'global'\n\t\t\t\t? Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tSingleton['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\t\t\t\tBasePath\n\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\tEphemeral,\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t\t\t: Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\tSingleton,\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\tMetadata,\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tEphemeral['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\t\tMetadata['schema'] & Ephemeral['schema']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t: Or<\n\t\t\t\t\tLifeCycleType extends AsType ? true : false,\n\t\t\t\t\tAsType extends 'local' ? true : false\n\t\t\t  > extends true\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema'] &\n\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox']>\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t: AsType extends 'global'\n\t\t\t\t? Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tSingleton['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tschema: Metadata['schema']\n\t\t\t\t\t\t\tstandaloneSchema: UnwrapRoute<\n\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\t\tBasePath\n\t\t\t\t\t\t\t> &\n\t\t\t\t\t\t\t\tMetadata['standaloneSchema']\n\t\t\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\tEphemeral,\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\t\t\t\t: Elysia<\n\t\t\t\t\t\tBasePath,\n\t\t\t\t\t\tSingleton,\n\t\t\t\t\t\tDefinitions,\n\t\t\t\t\t\tMetadata,\n\t\t\t\t\t\tRoutes,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\t\tEphemeral['resolve'] & MacroContext\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema'] &\n\t\t\t\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox']>\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVolatile\n\t\t\t\t\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Prettify<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t>\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t}\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Singleton['resolve'] & MacroContext\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<Singleton['resolve'] & MacroContext>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook:\n\t\t\t| (AnyLocalHook & {\n\t\t\t\t\tas: LifeCycleType\n\t\t\t  })\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tif (!run) {\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tthis.applyMacro(hook)\n\n\t\t\t\tif (hook.detail) {\n\t\t\t\t\tif (this.config.detail)\n\t\t\t\t\t\tthis.config.detail = mergeDeep(\n\t\t\t\t\t\t\tObject.assign({}, this.config.detail),\n\t\t\t\t\t\t\thook.detail\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.config.detail = hook.detail\n\t\t\t\t}\n\n\t\t\t\tif (hook.tags) {\n\t\t\t\t\tif (!this.config.detail)\n\t\t\t\t\t\tthis.config.detail = {\n\t\t\t\t\t\t\ttags: hook.tags\n\t\t\t\t\t\t}\n\t\t\t\t\telse this.config.detail.tags = hook.tags\n\t\t\t\t}\n\n\t\t\t\tconst type: LifeCycleType = hook.as ?? 'local'\n\n\t\t\t\tif (hook.schema === 'standalone') {\n\t\t\t\t\tif (!this.standaloneValidator[type])\n\t\t\t\t\t\tthis.standaloneValidator[type] = []\n\n\t\t\t\t\tconst response =\n\t\t\t\t\t\thook?.response ||\n\t\t\t\t\t\ttypeof hook?.response === 'string' ||\n\t\t\t\t\t\t(hook?.response && Kind in hook.response)\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t200: hook.response\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: hook?.response\n\n\t\t\t\t\tthis.standaloneValidator[type].push({\n\t\t\t\t\t\tbody: hook.body,\n\t\t\t\t\t\theaders: hook.headers,\n\t\t\t\t\t\tparams: hook.params,\n\t\t\t\t\t\tquery: hook.query,\n\t\t\t\t\t\tresponse,\n\t\t\t\t\t\tcookie: hook.cookie\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthis.validator[type] = {\n\t\t\t\t\t\tbody: hook.body ?? this.validator[type]?.body,\n\t\t\t\t\t\theaders: hook.headers ?? this.validator[type]?.headers,\n\t\t\t\t\t\tparams: hook.params ?? this.validator[type]?.params,\n\t\t\t\t\t\tquery: hook.query ?? this.validator[type]?.query,\n\t\t\t\t\t\tresponse: hook.response ?? this.validator[type]?.response,\n\t\t\t\t\t\tcookie: hook.cookie ?? this.validator[type]?.cookie\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hook.parse) this.on({ as: type }, 'parse', hook.parse)\n\t\t\t\tif (hook.transform)\n\t\t\t\t\tthis.on({ as: type }, 'transform', hook.transform)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.derive) this.on({ as: type }, 'derive', hook.derive)\n\t\t\t\tif (hook.beforeHandle)\n\t\t\t\t\tthis.on({ as: type }, 'beforeHandle', hook.beforeHandle)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.resolve) this.on({ as: type }, 'resolve', hook.resolve)\n\t\t\t\tif (hook.afterHandle)\n\t\t\t\t\tthis.on({ as: type }, 'afterHandle', hook.afterHandle)\n\t\t\t\tif (hook.mapResponse)\n\t\t\t\t\tthis.on({ as: type }, 'mapResponse', hook.mapResponse)\n\t\t\t\tif (hook.afterResponse)\n\t\t\t\t\tthis.on({ as: type }, 'afterResponse', hook.afterResponse)\n\t\t\t\tif (hook.error) this.on({ as: type }, 'error', hook.error)\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\treturn this.guard({} as any, hook)\n\t\t}\n\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst sandbox = run(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\t// ? Inject getServer for websocket and trace (important, do not remove)\n\t\tsandbox.getServer = () => this.server\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...(sandbox.event.request || [])\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...(sandbox.event.mapResponse || [])\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as AnyLocalHook, {\n\t\t\t\t\t\t...((localHook || {}) as AnyLocalHook),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t...(localHook.error ?? []),\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error ?? [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error ?? [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Inline fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin: (app: Param) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\tPrettify<Definitions & NewElysia['~Definitions']>,\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['~Ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['~Volatile']>\n\t>\n\n\t/**\n\t * Inline async fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin:\n\t\t\t| ((app: Param) => Promise<NewElysia>)\n\t\t\t| Promise<(app: Param) => NewElysia>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] &\n\t\t\t\t\tPartial<NewElysia['~Singleton']['decorator']>\n\t\t\t>\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] & Partial<NewElysia['~Singleton']['store']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Partial<NewElysia['~Singleton']['derive']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tPartial<NewElysia['~Singleton']['resolve']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & NewElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] & NewElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\t// @ts-expect-error this is truly ideal\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\t{\n\t\t\tschema: Prettify<\n\t\t\t\tEphemeral['schema'] & Partial<NewElysia['~Ephemeral']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tPartial<NewElysia['~Ephemeral']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tPartial<NewElysia['~Ephemeral']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tEphemeral['derive'] & Partial<NewElysia['~Ephemeral']['derive']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\tschema: Prettify<\n\t\t\t\tVolatile['schema'] & Partial<NewElysia['~Volatile']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] &\n\t\t\t\t\tPartial<NewElysia['~Volatile']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & Partial<NewElysia['~Volatile']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & Partial<NewElysia['~Volatile']['derive']>\n\t\t\t>\n\t\t}\n\t>\n\n\t/**\n\t * Entire Instance\n\t **/\n\tuse<const NewElysia extends AnyElysia>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\tPrettify2<Definitions & NewElysia['~Definitions']>,\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tEphemeral,\n\t\tPrettify2<Volatile & NewElysia['~Ephemeral']>\n\t>\n\n\t/**\n\t * Entire multiple Instance\n\t **/\n\tuse<const Instances extends AnyElysia[]>(\n\t\tinstance: MaybePromise<Instances>\n\t): MergeElysiaInstances<Instances, BasePath>\n\n\t/**\n\t * Import fn\n\t */\n\tuse<const NewElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: AnyElysia) => MaybePromise<NewElysia>\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['~Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & NewElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] & NewElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & NewElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['~Routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['~Ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['~Volatile']>\n\t>\n\n\t/**\n\t * Import entire instance\n\t */\n\tuse<const LazyLoadElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['decorator']>\n\t\t\t>\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['store']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['derive']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Singleton']['resolve']>\n\t\t\t>\n\t\t},\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] & LazyLoadElysia['~Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: Prettify<\n\t\t\t\tDefinitions['typebox'] &\n\t\t\t\t\tLazyLoadElysia['~Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Metadata & LazyLoadElysia['~Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & LazyLoadElysia['~Routes']\n\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['~Routes']>,\n\t\tEphemeral,\n\t\tPrettify2<{\n\t\t\tschema: Prettify<\n\t\t\t\tVolatile['schema'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['schema']>\n\t\t\t>\n\t\t\tstandaloneSchema: PrettifySchema<\n\t\t\t\tVolatile['standaloneSchema'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['standaloneSchema']>\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['resolve']>\n\t\t\t>\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] &\n\t\t\t\t\tPartial<LazyLoadElysia['~Ephemeral']['derive']>\n\t\t\t>\n\t\t}>\n\t>\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| MaybeArray<MaybePromise<AnyElysia>>\n\t\t\t| MaybePromise<\n\t\t\t\t\tAnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t| AnyElysia\n\t\t\t\t\t\t| ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  }>\n\t): AnyElysia {\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet app = this\n\t\t\tfor (const p of plugin) app = app.use(p) as any\n\t\t\treturn app\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin\n\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\tif (typeof plugin === 'function') return plugin(this)\n\n\t\t\t\t\t\tif (plugin instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin).compile()\n\n\t\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\t\treturn this._use(\n\t\t\t\t\t\t\t\tplugin as unknown as Elysia\n\t\t\t\t\t\t\t).compile()\n\n\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\treturn plugin.default(this)\n\n\t\t\t\t\t\tif (plugin.default instanceof Elysia)\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\tif (plugin.constructor.name === '_Elysia')\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn this._use(plugin.default)\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t'Invalid plugin type. Expected Elysia instance, function, or module with \"default\" as Elysia instance or function that returns Elysia instance.'\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then((v) => {\n\t\t\t\t\t\tif (v && typeof v.compile === 'function') v.compile()\n\n\t\t\t\t\t\treturn v\n\t\t\t\t\t})\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\treturn this._use(plugin)\n\t}\n\n\tprivate propagatePromiseModules(plugin: Elysia) {\n\t\tif (plugin.promisedModules.size <= 0) return this\n\n\t\tfor (const promise of plugin.promisedModules.promises)\n\t\t\tthis.promisedModules.add(\n\t\t\t\tpromise.then((v) => {\n\t\t\t\t\tif (!v) return\n\n\t\t\t\t\tconst t = this._use(v)\n\t\t\t\t\tif (t instanceof Promise)\n\t\t\t\t\t\treturn t.then((v2) => {\n\t\t\t\t\t\t\tif (v2) v2.compile()\n\t\t\t\t\t\t\telse v.compile()\n\t\t\t\t\t\t})\n\n\t\t\t\t\treturn v.compile()\n\t\t\t\t})\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\tprivate _use(\n\t\tplugin: AnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.promisedModules.add(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tplugin.getServer = () => this.getServer()\n\t\t\t\t\t\t\t\tplugin.getGlobalRoutes = () =>\n\t\t\t\t\t\t\t\t\tthis.getGlobalRoutes()\n\t\t\t\t\t\t\t\tplugin.getGlobalDefinitions = () =>\n\t\t\t\t\t\t\t\t\tthis.getGlobalDefinitions()\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Model and error is required for Swagger generation\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tplugin.model(this.definitions.type as any)\n\t\t\t\t\t\t\t\tplugin.error(this.definitions.error as any)\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks,\n\t\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t\t} of Object.values(plugin.router.history))\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tisNotEmpty(plugin.event.error)\n\t\t\t\t\t\t\t\t\t\t\t? mergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t: hooks,\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tstandaloneValidators\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tif (plugin === this) return\n\n\t\t\t\t\t\t\t\tthis.propagatePromiseModules(plugin)\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((v) => {\n\t\t\t\t\t\t\tif (v && typeof v.compile === 'function')\n\t\t\t\t\t\t\t\tv.compile()\n\n\t\t\t\t\t\t\treturn v\n\t\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tthis.propagatePromiseModules(plugin)\n\n\t\tconst name = plugin.config.name\n\t\tconst seed = plugin.config.seed\n\n\t\tplugin.getParent = () => this as any\n\t\tplugin.getServer = () => this.getServer()\n\t\tplugin.getGlobalRoutes = () => this.getGlobalRoutes()\n\t\tplugin.getGlobalDefinitions = () => this.getGlobalDefinitions()\n\n\t\tif (plugin.standaloneValidator?.scoped) {\n\t\t\tif (this.standaloneValidator.local)\n\t\t\t\tthis.standaloneValidator.local =\n\t\t\t\t\tthis.standaloneValidator.local.concat(\n\t\t\t\t\t\tplugin.standaloneValidator.scoped\n\t\t\t\t\t)\n\t\t\telse\n\t\t\t\tthis.standaloneValidator.local =\n\t\t\t\t\tplugin.standaloneValidator.scoped\n\t\t}\n\n\t\tif (plugin.standaloneValidator?.global) {\n\t\t\tif (this.standaloneValidator.global)\n\t\t\t\tthis.standaloneValidator.global =\n\t\t\t\t\tthis.standaloneValidator.global.concat(\n\t\t\t\t\t\tplugin.standaloneValidator.global\n\t\t\t\t\t)\n\t\t\telse\n\t\t\t\tthis.standaloneValidator.global =\n\t\t\t\t\tplugin.standaloneValidator.global\n\t\t}\n\n\t\t/**\n\t\t * Model and error is required for Swagger generation\n\t\t */\n\t\t// plugin.model(this.definitions.type as any)\n\t\t// plugin.error(this.definitions.error as any)\n\n\t\tif (isNotEmpty(plugin['~parser']))\n\t\t\tthis['~parser'] = {\n\t\t\t\t...plugin['~parser'],\n\t\t\t\t...this['~parser']\n\t\t\t}\n\n\t\tif (plugin.setHeaders) this.headers(plugin.setHeaders)\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tif (plugin.extender.macros.length)\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\n\t\t\tif (plugin.extender.higherOrderFunctions.length)\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t}\n\n\t\t// ! Deduplicate current instance\n\t\tdeduplicateChecksum(this.extender.macros)\n\n\t\tif (plugin.extender.higherOrderFunctions.length) {\n\t\t\tdeduplicateChecksum(this.extender.higherOrderFunctions)\n\n\t\t\t// ! Deduplicate current instance\n\t\t\tconst hofHashes: number[] = []\n\t\t\tfor (\n\t\t\t\tlet i = 0;\n\t\t\t\ti < this.extender.higherOrderFunctions.length;\n\t\t\t\ti++\n\t\t\t) {\n\t\t\t\tconst hof = this.extender.higherOrderFunctions[i]\n\n\t\t\t\tif (hof.checksum) {\n\t\t\t\t\tif (hofHashes.includes(hof.checksum)) {\n\t\t\t\t\t\tthis.extender.higherOrderFunctions.splice(i, 1)\n\t\t\t\t\t\ti--\n\t\t\t\t\t}\n\n\t\t\t\t\thofHashes.push(hof.checksum)\n\t\t\t\t}\n\t\t\t}\n\t\t\thofHashes.length = 0\n\t\t}\n\n\t\tthis.inference = mergeInference(this.inference, plugin.inference)\n\n\t\tif (isNotEmpty(plugin.singleton.decorator))\n\t\t\tthis.decorate(plugin.singleton.decorator)\n\n\t\tif (isNotEmpty(plugin.singleton.store))\n\t\t\tthis.state(plugin.singleton.store)\n\n\t\tif (isNotEmpty(plugin.definitions.type))\n\t\t\tthis.model(plugin.definitions.type)\n\n\t\tif (isNotEmpty(plugin.definitions.error))\n\t\t\tthis.error(plugin.definitions.error as any)\n\n\t\tif (isNotEmpty(plugin.definitions.error))\n\t\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\t\tplugin.extender.macros\n\t\t\t)\n\n\t\tfor (const {\n\t\t\tmethod,\n\t\t\tpath,\n\t\t\thandler,\n\t\t\thooks,\n\t\t\tstandaloneValidators\n\t\t} of Object.values(plugin.router.history)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tisNotEmpty(plugin.event.error)\n\t\t\t\t\t? mergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t})\n\t\t\t\t\t: hooks,\n\t\t\t\tundefined,\n\t\t\t\tstandaloneValidators\n\t\t\t)\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t)\n\t\t\t\treturn this\n\n\t\t\tthis.dependencies[name].push(\n\t\t\t\tthis.config?.analytic\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\tstack: plugin.telemetry?.stack,\n\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\tdecorators: plugin.singleton,\n\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'derive')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'resolve')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t} as any)\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (isNotEmpty(plugin.event))\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\t\tcurrent\n\t\t\t\t)\n\t\t} else {\n\t\t\tif (isNotEmpty(plugin.event))\n\t\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\t\tthis.event,\n\t\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t\t)\n\t\t}\n\n\t\tif (plugin.validator.global)\n\t\t\t// @ts-ignore\n\t\t\tthis.validator.global = mergeHook(this.validator.global, {\n\t\t\t\t...plugin.validator.global\n\t\t\t}) as any\n\n\t\tif (plugin.validator.scoped)\n\t\t\t// @ts-ignore\n\t\t\tthis.validator.local = mergeHook(this.validator.local, {\n\t\t\t\t...plugin.validator.scoped\n\t\t\t})\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacroFn>(\n\t\tmacro: (\n\t\t\troute: MacroManager<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t\t},\n\t\t\t\tDefinitions['error']\n\t\t\t>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro<\n\t\tconst NewMacro extends HookMacroFn<\n\t\t\tMetadata['schema'],\n\t\t\tSingleton & {\n\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t},\n\t\t\tDefinitions['error']\n\t\t>\n\t>(\n\t\tmacro: NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tstandaloneSchema: Metadata['standaloneSchema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro(macro: Function | Record<keyof any, Function>) {\n\t\tif (typeof macro === 'function') {\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: macro.toString()\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: macro as any\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t} else if (typeof macro === 'object') {\n\t\t\tfor (const name of Object.keys(macro))\n\t\t\t\tif (typeof macro[name] === 'object') {\n\t\t\t\t\tconst actualValue = { ...(macro[name] as Object) }\n\n\t\t\t\t\tmacro[name] = (v: boolean) => {\n\t\t\t\t\t\tif (v === true) return actualValue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: Object.entries(macro)\n\t\t\t\t\t\t\t.map(([k, v]) => `${k}+${v}`)\n\t\t\t\t\t\t\t.join(',')\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: () => macro\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia,\n\t\tdetail?: { detail?: DocumentDecoration }\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia,\n\t\tdetail?: { detail?: DocumentDecoration }\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia,\n\t\thandleOrConfig?:\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia\n\t\t\t| { detail?: DocumentDecoration },\n\t\tconfig?: { detail?: DocumentDecoration }\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t\t: handleOrConfig instanceof Elysia\n\t\t\t\t\t\t\t? handleOrConfig.compile().fetch\n\t\t\t\t\t\t\t: typeof handleOrConfig === 'function'\n\t\t\t\t\t\t\t\t? handleOrConfig\n\t\t\t\t\t\t\t\t: (() => {\n\t\t\t\t\t\t\t\t\t\tthrow new Error('Invalid handler')\n\t\t\t\t\t\t\t\t\t})()\n\n\t\t\tconst handler: Handler = ({ request, path }) =>\n\t\t\t\trun(\n\t\t\t\t\tnew Request(replaceUrlPath(request.url, path), {\n\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\theaders: request.headers,\n\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\tcredentials: request.credentials,\n\t\t\t\t\t\treferrerPolicy: request.referrerPolicy as any,\n\t\t\t\t\t\tduplex: request.duplex,\n\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\tmode: request.mode,\n\t\t\t\t\t\tkeepalive: request.keepalive,\n\t\t\t\t\t\tintegrity: request.integrity,\n\t\t\t\t\t\tbody: request.body\n\t\t\t\t\t})\n\t\t\t\t)\n\n\t\t\tthis.route('ALL', '/*', handler as any, {\n\t\t\t\tparse: 'none',\n\t\t\t\t...config,\n\t\t\t\tdetail: {\n\t\t\t\t\t...config?.detail,\n\t\t\t\t\thide: true\n\t\t\t\t},\n\t\t\t\tconfig: {\n\t\t\t\t\tmount: run\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst handle =\n\t\t\thandleOrConfig instanceof Elysia\n\t\t\t\t? handleOrConfig.compile().fetch\n\t\t\t\t: typeof handleOrConfig === 'function'\n\t\t\t\t\t? handleOrConfig\n\t\t\t\t\t: (() => {\n\t\t\t\t\t\t\tthrow new Error('Invalid handler')\n\t\t\t\t\t\t})()\n\n\t\tconst length = path.length - (path.endsWith('*') ? 1 : 0)\n\n\t\tconst handler: Handler = ({ request, path }) =>\n\t\t\thandle(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\t{\n\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\theaders: request.headers,\n\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\tcredentials: request.credentials,\n\t\t\t\t\t\treferrerPolicy: request.referrerPolicy as any,\n\t\t\t\t\t\tduplex: request.duplex,\n\t\t\t\t\t\tredirect: request.redirect,\n\t\t\t\t\t\tmode: request.mode,\n\t\t\t\t\t\tkeepalive: request.keepalive,\n\t\t\t\t\t\tintegrity: request.integrity,\n\t\t\t\t\t\tbody: request.body\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\n\t\tthis.route('ALL', path, handler as any, {\n\t\t\tparse: 'none',\n\t\t\t...config,\n\t\t\tdetail: {\n\t\t\t\t...config?.detail,\n\t\t\t\thide: true\n\t\t\t},\n\t\t\tconfig: {\n\t\t\t\tmount: handle\n\t\t\t}\n\t\t})\n\n\t\tthis.route(\n\t\t\t'ALL',\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\tparse: 'none',\n\t\t\t\t...config,\n\t\t\t\tdetail: {\n\t\t\t\t\t...config?.detail,\n\t\t\t\t\thide: true\n\t\t\t\t},\n\t\t\t\tconfig: {\n\t\t\t\t\tmount: handle\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with method [ALL]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t *     .all('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with method [ROUTE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('/', () => 'hi')\n\t *     .route('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t> &\n\t\t\tMetadata['standaloneSchema'] &\n\t\t\tEphemeral['standaloneSchema'] &\n\t\t\tVolatile['standaloneSchema'],\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Decorator extends Singleton & {\n\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\tVolatile['resolve'] &\n\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t},\n\t\tconst Handle extends InlineHandler<\n\t\t\tNoInfer<Schema>,\n\t\t\tDecorator,\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tDecorator,\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['parser']\n\t\t> & {\n\t\t\tconfig?: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t\tmount?: Function\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add(method.toUpperCase(), path, handler as any, hook, hook?.config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof Definitions['typebox'] & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t>(\n\t\tpath: Path,\n\t\toptions: WSLocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], Macro>\n\t\t\t},\n\t\t\tMacro\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: IsNever<keyof Schema['params']> extends true\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: {} extends Schema['response']\n\t\t\t\t\t\t\t? unknown\n\t\t\t\t\t\t\t: Schema['response'] extends { [200]: any }\n\t\t\t\t\t\t\t\t? Schema['response'][200]\n\t\t\t\t\t\t\t\t: unknown\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (this['~adapter'].ws) this['~adapter'].ws(this, path, options as any)\n\t\telse console.warn(`Current adapter doesn't support WebSocket`)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<const Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<\n\t\t\t\tSingleton['store'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Prettify<Singleton['store'] & Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string | number | symbol,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Type extends 'override'\n\t\t\t\t? Reconcile<\n\t\t\t\t\t\tSingleton['store'],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t>\n\t\t\t\t: Prettify<\n\t\t\t\t\t\tSingleton['store'] & {\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tStore extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Type extends 'override'\n\t\t\t\t? Reconcile<Singleton['store'], Store>\n\t\t\t\t: Prettify<Singleton['store'] & Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: NewStore\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (!value || !isNotEmpty(value)) return this\n\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.store)\n\t\t\t\t\t\tthis.singleton.store[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.store[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.store[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.store = mergeDeep(this.singleton.store, value, {\n\t\t\t\t\toverride: as === 'override'\n\t\t\t\t})\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\t\tthis.singleton.store[name] = value\n\t\t\t\t} else this.singleton.store = value(this.singleton.store)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\tthis.singleton.store[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<\n\t\t\t\tSingleton['decorator'] & {\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Prettify<Singleton['decorator'] & NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tdecorate<NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['decorator']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: NewDecorators\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate({ as: 'override' }, 'getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'override'\n\t\t\t\t? Reconcile<\n\t\t\t\t\t\tSingleton['decorator'],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t>\n\t\t\t\t: Prettify<\n\t\t\t\t\t\tSingleton['decorator'] & {\n\t\t\t\t\t\t\t[name in Name]: Value\n\t\t\t\t\t\t}\n\t\t\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tNewDecorators extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'override'\n\t\t\t\t? Reconcile<Singleton['decorator'], NewDecorators, true>\n\t\t\t\t: Prettify<Singleton['decorator'] & NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.decorator)\n\t\t\t\t\t\tthis.singleton.decorator[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.decorator[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.decorator[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.decorator = mergeDeep(\n\t\t\t\t\tthis.singleton.decorator,\n\t\t\t\t\tvalue,\n\t\t\t\t\t{\n\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tas === 'override' ||\n\t\t\t\t\t\t!(name in this.singleton.decorator)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.singleton.decorator[name] = value\n\t\t\t\t} else\n\t\t\t\t\tthis.singleton.decorator = value(this.singleton.decorator)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.decorator))\n\t\t\t\t\tthis.singleton.decorator[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\t\tVolatile['standaloneSchema']\n\t\t\t\t\t&\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Singleton['resolve']\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tVolatile['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tderive(\n\t\toptionsOrTransform: { as?: LifeCycleType } | Function,\n\t\ttransform?: Function\n\t) {\n\t\tif (!transform) {\n\t\t\ttransform = optionsOrTransform as any\n\t\t\toptionsOrTransform = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: transform!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrTransform as any, hook as any) as any\n\t}\n\n\tmodel<const Name extends string, const Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox'] & {\n\t\t\t\t[name in Name]: Model\n\t\t\t}\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const Recorder extends TProperties>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox'] & Recorder\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (\n\t\t\tdecorators: Definitions['typebox'] extends infer Models extends\n\t\t\t\tRecord<string, TSchema>\n\t\t\t\t? {\n\t\t\t\t\t\t[type in keyof Models]: TRef<// @ts-ignore\n\t\t\t\t\t\ttype>\n\t\t\t\t\t}\n\t\t\t\t: {}\n\t\t) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: {\n\t\t\t\t[key in keyof NewType]: NewType[key] extends TRef<key & string>\n\t\t\t\t\t? // @ts-expect-error\n\t\t\t\t\t\tDefinitions['typebox'][key]\n\t\t\t\t\t: NewType[key]\n\t\t\t}\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tconst parsedSchemas = {} as Record<string, TSchema>\n\n\t\t\t\tconst kvs = Object.entries(name)\n\n\t\t\t\tif (!kvs.length) return this\n\n\t\t\t\tfor (const [key, value] of kvs) {\n\t\t\t\t\tif (key in this.definitions.type) continue\n\n\t\t\t\t\tparsedSchemas[key] = this.definitions.type[key] = value\n\t\t\t\t\tparsedSchemas[key].$id ??= `#/components/schemas/${key}`\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...parsedSchemas\n\t\t\t\t} as any)\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tconst result = name(this.definitions.type)\n\t\t\t\tthis.definitions.type = result\n\t\t\t\tthis.definitions.typebox = t.Module(result as any)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'string':\n\t\t\t\tif (!model) break\n\n\t\t\t\tconst newModel = {\n\t\t\t\t\t...model,\n\t\t\t\t\tid: model.$id ?? `#/components/schemas/${name}`\n\t\t\t\t}\n\n\t\t\t\tthis.definitions.type[name] = model\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...newModel\n\t\t\t\t} as any)\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\t\tthis.definitions.typebox = t.Module({\n\t\t\t...this.definitions.typebox['$defs'],\n\t\t\t[name]: model!\n\t\t} as any)\n\n\t\treturn this as any\n\t}\n\n\tRef<K extends keyof Definitions['typebox'] & string>(key: K) {\n\t\treturn t.Ref(key)\n\t}\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: ExcludeElysiaResponse<NewDerivative>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t}\n\t>\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\tstandaloneSchema: Ephemeral['standaloneSchema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t\tstandaloneSchema: Volatile['standaloneSchema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapDerive(\n\t\toptionsOrDerive: { as?: LifeCycleType } | Function,\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrDerive as any\n\t\t\toptionsOrDerive = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapDerive',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrDerive as any, hook as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['decorator']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t: Singleton['decorator']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['store']>\n\t\t\t\t\t: AddSuffix<Word, Singleton['store']>\n\t\t\t\t: Singleton['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['derive']>\n\t\t\t\t: Singleton['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t: Singleton['resolve']\n\t\t},\n\t\t{\n\t\t\ttypebox: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['typebox']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['typebox']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['typebox']>\n\t\t\t\t: Definitions['typebox']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t\t: (suffix: string, word: string) =>\n\t\t\t\t\t\t\tword + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.singleton.decorator) {\n\t\t\t\t\t\tstore[joinKey(word, key)] =\n\t\t\t\t\t\t\tthis.singleton.decorator[key]\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.singleton.decorator = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.singleton.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.singleton.store[key]\n\n\t\t\t\t\tthis.singleton.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tif (this['~adapter'].isWebStandard) {\n\t\t\tthis.fetch = this.config.aot\n\t\t\t\t? composeGeneralHandler(this)\n\t\t\t\t: createDynamicHandler(this)\n\n\t\t\tif (typeof this.server?.reload === 'function')\n\t\t\t\tthis.server.reload({\n\t\t\t\t\t...(this.server || {}),\n\t\t\t\t\tfetch: this.fetch\n\t\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload(this.server || {})\n\n\t\tthis._handle = composeGeneralHandler(this)\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\t/**\n\t * Custom handle written by adapter\n\t */\n\tprotected _handle?(...a: unknown[]): unknown\n\n\tprotected handleError = async (\n\t\tcontext: Partial<\n\t\t\tContext<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t> &\n\t\t\t\t\tMetadata['standaloneSchema'] &\n\t\t\t\t\tEphemeral['standaloneSchema'] &\n\t\t\t\t\tVolatile['standaloneSchema'],\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t> & {\n\t\t\trequest: Request\n\t\t},\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) => {\n\t\treturn (this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\t}\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tthis['~adapter'].listen(this)(options, callback)\n\n\t\tif (this.promisedModules.size) clearSucroseCache(5000)\n\n\t\tthis.promisedModules.then(() => {\n\t\t\tclearSucroseCache(1000)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * app.stop(true) // Abruptly any requests inflight\n\t * ```\n\t */\n\tstop = async (closeActiveConnections?: boolean) => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tif (this.server) {\n\t\t\tthis.server.stop(closeActiveConnections)\n\t\t\tthis.server = null\n\n\t\t\tif (this.event.stop?.length)\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn this.promisedModules\n\t}\n}\n\nexport { Elysia }\n\nexport { t } from './type-system'\nexport { serializeCookie, Cookie, type CookieOptions } from './cookies'\nexport type { Context, PreContext, ErrorContext } from './context'\nexport {\n\tELYSIA_TRACE,\n\ttype TraceEvent,\n\ttype TraceListener,\n\ttype TraceHandler,\n\ttype TraceProcess,\n\ttype TraceStream\n} from './trace'\n\nexport {\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\treplaceSchemaType\n} from './schema'\n\nexport {\n\tmergeHook,\n\tmergeObjectArray,\n\tredirect,\n\tStatusMap,\n\tInvertedStatusMap,\n\tform,\n\treplaceUrlPath,\n\tchecksum,\n\tcloneInference,\n\tdeduplicateChecksum,\n\tELYSIA_FORM_DATA,\n\tELYSIA_REQUEST_ID,\n\tsse\n} from './utils'\n\nexport {\n\tstatus,\n\terror,\n\tmapValueError,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature,\n\tERROR_CODE\n} from './error'\n\nexport type {\n\tEphemeralType,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterResponseHandler,\n\tErrorHandler,\n\tLifeCycleEvent,\n\tLifeCycleStore,\n\tLifeCycleType,\n\tMaybePromise,\n\tUnwrapSchema,\n\tChecksum,\n\tDocumentDecoration,\n\tInferContext,\n\tInferHandler,\n\tResolvePath,\n\tMapResponse,\n\tMacroQueue,\n\tBaseMacro,\n\tMacroManager,\n\tBaseMacroFn,\n\tMacroToProperty,\n\tResolveMacroContext,\n\tMergeElysiaInstances,\n\tMaybeArray,\n\tModelValidator,\n\tMetadataBase,\n\tUnwrapBodySchema,\n\tUnwrapGroupGuardRoute,\n\tModelValidatorError,\n\tExcludeElysiaResponse,\n\tSSEPayload,\n\tStandaloneInputSchema,\n\tMergeStandaloneSchema,\n\tMergeTypeModule,\n\tGracefulHandler,\n\tAfterHandler,\n\tInlineHandler,\n\tResolveHandler,\n\tTransformHandler,\n\tHTTPHeaders\n} from './types'\n\nexport { env } from './universal/env'\nexport { file, ElysiaFile } from './universal/file'\nexport type { ElysiaAdapter } from './adapter'\n\nexport { TypeSystemPolicy } from '@sinclair/typebox/system'\nexport type { Static, TSchema } from '@sinclair/typebox'\n",
    "import { Type, Kind } from '@sinclair/typebox'\nimport type {\n\tArrayOptions,\n\tDateOptions,\n\tIntegerOptions,\n\tObjectOptions,\n\tSchemaOptions,\n\tTAnySchema,\n\tTArray,\n\tTBoolean,\n\tTDate,\n\tTEnumValue,\n\tTInteger,\n\tTNumber,\n\tTObject,\n\tTProperties,\n\tTSchema,\n\tTString,\n\tNumberOptions,\n\tJavaScriptTypeBuilder,\n\tStringOptions,\n\tTUnsafe\n} from '@sinclair/typebox'\n\nimport './format'\nimport {\n\tcompile,\n\tcreateType,\n\tloadFileType,\n\ttryParse,\n\tvalidateFile\n} from './utils'\nimport {\n\tCookieValidatorOptions,\n\tTFile,\n\tTFiles,\n\tFileOptions,\n\tFilesOptions,\n\tNonEmptyArray,\n\tTForm,\n\tTUnionEnum,\n\tElysiaTransformDecodeBuilder\n} from './types'\n\nimport { ELYSIA_FORM_DATA, form } from '../utils'\nimport { ValidationError } from '../error'\nimport { parseDateTimeEmptySpace } from './format'\n\nconst t = Object.assign({}, Type) as unknown as Omit<\n\tJavaScriptTypeBuilder,\n\t'String' | 'Transform'\n> &\n\ttypeof ElysiaType & {\n\t\tTransform<Type extends TSchema>(\n\t\t\ttype: Type\n\t\t): ElysiaTransformDecodeBuilder<Type>\n\t}\n\ncreateType<TUnionEnum>(\n\t'UnionEnum',\n\t(schema, value) =>\n\t\t(typeof value === 'number' ||\n\t\t\ttypeof value === 'string' ||\n\t\t\tvalue === null) &&\n\t\tschema.enum.includes(value as never)\n)\n\nconst internalFiles = createType<FilesOptions, File[]>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n) as unknown as TFiles\n\nconst internalFormData = createType<TForm, FormData>(\n\t'ElysiaForm',\n\t({ compiler, ...schema }, value) => {\n\t\tif (!(value instanceof FormData)) return false\n\n\t\tif (compiler) {\n\t\t\tif (!(ELYSIA_FORM_DATA in value))\n\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\tif (!compiler.Check(value[ELYSIA_FORM_DATA]))\n\t\t\t\tthrow compiler.Error(value[ELYSIA_FORM_DATA])\n\t\t}\n\n\t\treturn true\n\t}\n) as unknown as TForm\n\ninterface ElysiaStringOptions extends StringOptions {\n\t/**\n\t * Whether the value include JSON escape sequences or not\n\t *\n\t * When using JSON Accelerator, this will bypass the JSON escape sequence validation\n\t *\n\t * Set to `true` if the value doesn't include JSON escape sequences\n\t *\n\t * @default false\n\t */\n\ttrusted?: boolean\n}\n\nexport const ElysiaType = {\n\t// @ts-ignore\n\tString: (property?: ElysiaStringOptions) => Type.String(property),\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !compiler.Check(number))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\n\tInteger: (property?: IntegerOptions): TInteger => {\n\t\tconst schema = Type.Integer(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'integer',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tType.Integer(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\n\t\t\t\tif (!compiler.Check(number)) throw compiler.Error(number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TInteger\n\t},\n\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\t\tconst compiler = compile(schema)\n\n\t\tconst _default = property?.default\n\t\t\t? new Date(property.default) // in case the default is an ISO string or milliseconds from epoch\n\t\t\t: undefined\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number({ default: _default?.getTime() })\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'number') {\n\t\t\t\t\tconst date = new Date(value)\n\n\t\t\t\t\tif (!compiler.Check(date)) throw compiler.Error(date)\n\n\t\t\t\t\treturn date\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(parseDateTimeEmptySpace(value))\n\n\t\t\t\tif (!date || isNaN(date.getTime()))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\tif (!compiler.Check(date)) throw compiler.Error(date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => value.toISOString()) as any as TDate\n\t},\n\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\t\tconst compiler = compile(schema)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.Boolean(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (value !== undefined && !compiler.Check(value))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst compiler = compile(schema)\n\n\t\tconst defaultValue = JSON.stringify(compiler.Create())\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tif (value.charCodeAt(0) !== 123)\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\tif (!compiler.Check((value = tryParse(value, schema))))\n\t\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tlet original\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\tvalue = tryParse((original = value), schema)\n\n\t\t\t\tif (!compiler.Check(value)) throw compiler.Error(value)\n\n\t\t\t\treturn original ?? JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\n\tArrayString: <T extends TSchema = TString>(\n\t\tchildren: T = t.String() as any,\n\t\toptions?: ArrayOptions\n\t) => {\n\t\tconst schema = t.Array(children, options)\n\t\tconst compiler = compile(schema)\n\n\t\tconst decode = (value: string, isProperty = false) => {\n\t\t\tif (value.charCodeAt(0) === 91) {\n\t\t\t\tif (!compiler.Check((value = tryParse(value, schema))))\n\t\t\t\t\tthrow compiler.Error(value)\n\n\t\t\t\treturn compiler.Decode(value)\n\t\t\t}\n\n\t\t\t// has , (as used in nuqs)\n\t\t\tif (value.indexOf(',') !== -1) {\n\t\t\t\t// const newValue = value.split(',').map((v) => v.trim())\n\n\t\t\t\tif (!compiler.Check(value)) throw compiler.Error(value)\n\n\t\t\t\treturn compiler.Decode(value)\n\t\t\t}\n\n\t\t\tif (isProperty) return value\n\n\t\t\tthrow new ValidationError('property', schema, value)\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ArrayString',\n\t\t\t\t\t\tdefault: options?.default\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tlet values = <unknown[]>[]\n\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tconst v = value[i]\n\t\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\t\tconst t = decode(v, true)\n\t\t\t\t\t\t\tif (Array.isArray(t)) values = values.concat(t)\n\t\t\t\t\t\t\telse values.push(t)\n\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalues.push(v)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values\n\t\t\t\t}\n\n\t\t\t\tif (typeof value === 'string') return decode(value)\n\n\t\t\t\t// Is probably transformed, unable to check schema\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tlet original\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\tvalue = tryParse((original = value), schema)\n\n\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn original ?? JSON.stringify(value)\n\t\t\t}) as any as TArray<T>\n\t},\n\n\tFile: createType<FileOptions, File>(\n\t\t'File',\n\t\tvalidateFile\n\t) as unknown as TFile,\n\n\tFiles: (options: FilesOptions = {}): TUnsafe<File[]> =>\n\t\tt\n\t\t\t.Transform(internalFiles(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value) as unknown as TUnsafe<File[]>,\n\n\tNullable: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null()], options),\n\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null(), t.Undefined()], options),\n\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: CookieValidatorOptions<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t},\n\n\tUnionEnum: <\n\t\tconst T extends\n\t\t\t| NonEmptyArray<TEnumValue>\n\t\t\t| Readonly<NonEmptyArray<TEnumValue>>\n\t>(\n\t\tvalues: T,\n\t\toptions: SchemaOptions = {}\n\t) => {\n\t\tconst type = values.every((value) => typeof value === 'string')\n\t\t\t? { type: 'string' }\n\t\t\t: values.every((value) => typeof value === 'number')\n\t\t\t\t? { type: 'number' }\n\t\t\t\t: values.every((value) => value === null)\n\t\t\t\t\t? { type: 'null' }\n\t\t\t\t\t: {}\n\n\t\tif (values.some((x) => typeof x === 'object' && x !== null))\n\t\t\tthrow new Error('This type does not support objects or arrays')\n\n\t\treturn {\n\t\t\t// default is need for generating error message\n\t\t\tdefault: values[0],\n\t\t\t...options,\n\t\t\t[Kind]: 'UnionEnum',\n\t\t\t...type,\n\t\t\tenum: values\n\t\t} as any as TUnionEnum<T>\n\t},\n\n\tNoValidate: <T extends TAnySchema>(v: T, enabled = true) => {\n\t\tv.noValidate = enabled\n\n\t\treturn v\n\t},\n\n\tForm: <T extends TProperties>(\n\t\tv: T,\n\t\toptions: ObjectOptions = {}\n\t): TForm<T> => {\n\t\tconst schema = t.Object(v, {\n\t\t\tdefault: form({}),\n\t\t\t...options\n\t\t})\n\t\tconst compiler = compile(schema)\n\n\t\treturn t.Union([\n\t\t\tschema,\n\t\t\t// @ts-expect-error\n\t\t\tinternalFormData({\n\t\t\t\tcompiler\n\t\t\t})\n\t\t])\n\t}\n}\n\nt.BooleanString = ElysiaType.BooleanString\nt.ObjectString = ElysiaType.ObjectString\nt.ArrayString = ElysiaType.ArrayString\nt.Numeric = ElysiaType.Numeric\nt.Integer = ElysiaType.Integer\n\nt.File = (arg) => {\n\tif (arg?.type) loadFileType()\n\n\treturn ElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n}\n\nt.Files = (arg) => {\n\tif (arg?.type) loadFileType()\n\n\treturn ElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n}\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty as any\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\nt.UnionEnum = ElysiaType.UnionEnum\nt.NoValidate = ElysiaType.NoValidate\nt.Form = ElysiaType.Form\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeRegistry, FormatRegistry } from '@sinclair/typebox'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n",
    "import { FormatRegistry } from '@sinclair/typebox'\n\n/**\n * ? Fork of ajv-formats without ajv as dependencies\n *\n * @see https://github.com/ajv-validator/ajv-formats/blob/master/src/formats.ts\n **/\n\n/* eslint-disable no-control-regex */\nexport type FormatName =\n\t| 'date'\n\t| 'time'\n\t| 'date-time'\n\t| 'iso-time'\n\t| 'iso-date-time'\n\t| 'duration'\n\t| 'uri'\n\t| 'uri-reference'\n\t| 'uri-template'\n\t| 'url'\n\t| 'email'\n\t| 'hostname'\n\t| 'ipv4'\n\t| 'ipv6'\n\t| 'regex'\n\t| 'uuid'\n\t| 'json-pointer'\n\t| 'json-pointer-uri-fragment'\n\t| 'relative-json-pointer'\n\t| 'byte'\n\t| 'int32'\n\t| 'int64'\n\t| 'float'\n\t| 'double'\n\t| 'password'\n\t| 'binary'\n\nexport const fullFormats = {\n\t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n\tdate,\n\t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n\ttime: getTime(true),\n\t'date-time': getDateTime(true),\n\t'iso-time': getTime(false),\n\t'iso-date-time': getDateTime(false),\n\t// duration: https://tools.ietf.org/html/rfc3339#appendix-A\n\tduration:\n\t\t/^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n\turi,\n\t'uri-reference':\n\t\t/^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n\t// uri-template: https://tools.ietf.org/html/rfc6570\n\t'uri-template':\n\t\t/^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\t// For the source: https://gist.github.com/dperini/729294\n\t// For test cases: https://mathiasbynens.be/demo/url-regex\n\turl: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n\temail: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n\thostname:\n\t\t/^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n\t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n\tipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n\tipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n\tregex,\n\t// uuid: http://tools.ietf.org/html/rfc4122\n\tuuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\t// JSON-pointer: https://tools.ietf.org/html/rfc6901\n\t// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n\t'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n\t'json-pointer-uri-fragment':\n\t\t/^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\t// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n\t'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\t// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n\t// byte: https://github.com/miguelmota/is-base64\n\tbyte,\n\t// signed 32 bit integer\n\tint32: { type: 'number', validate: validateInt32 },\n\t// signed 64 bit integer\n\tint64: { type: 'number', validate: validateInt64 },\n\t// C-type float\n\tfloat: { type: 'number', validate: validateNumber },\n\t// C-type double\n\tdouble: { type: 'number', validate: validateNumber },\n\t// hint to the UI to hide input strings\n\tpassword: true,\n\t// unchecked string payload\n\tbinary: true\n} as const\n\nfunction isLeapYear(year: number): boolean {\n\t// https://tools.ietf.org/html/rfc3339#appendix-C\n\treturn year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n\t// full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n\tconst matches: string[] | null = DATE.exec(str)\n\tif (!matches) return false\n\tconst year: number = +matches[1]\n\tconst month: number = +matches[2]\n\tconst day: number = +matches[3]\n\treturn (\n\t\tmonth >= 1 &&\n\t\tmonth <= 12 &&\n\t\tday >= 1 &&\n\t\tday <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n\t)\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n\treturn function time(str: string): boolean {\n\t\tconst matches: string[] | null = TIME.exec(str)\n\t\tif (!matches) return false\n\t\tconst hr: number = +matches[1]\n\t\tconst min: number = +matches[2]\n\t\tconst sec: number = +matches[3]\n\t\tconst tz: string | undefined = matches[4]\n\t\tconst tzSign: number = matches[5] === '-' ? -1 : 1\n\t\tconst tzH: number = +(matches[6] || 0)\n\t\tconst tzM: number = +(matches[7] || 0)\n\t\tif (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n\t\tif (hr <= 23 && min <= 59 && sec < 60) return true\n\t\t// leap second\n\t\tconst utcMin = min - tzM * tzSign\n\t\tconst utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n\t\treturn (\n\t\t\t(utcHr === 23 || utcHr === -1) &&\n\t\t\t(utcMin === 59 || utcMin === -1) &&\n\t\t\tsec < 61\n\t\t)\n\t}\n}\n\nexport const parseDateTimeEmptySpace = (str: string) => {\n\tif (str.charCodeAt(str.length - 6) === 32)\n\t\treturn str.slice(0, -6) + '+' + str.slice(-5)\n\n\treturn str\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n\tconst time = getTime(strictTimeZone)\n\n\treturn function date_time(str: string): boolean {\n\t\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\t\tconst dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n\n\t\treturn dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n\t}\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n\t/^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n\t// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n\treturn NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE =\n\t/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n\tBYTE.lastIndex = 0\n\treturn BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n\treturn Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n\t// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n\treturn Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n\treturn true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n\tif (Z_ANCHOR.test(str)) return false\n\ttry {\n\t\tnew RegExp(str)\n\t\treturn true\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\n/**\n * @license\n *\n * MIT License\n *\n * Copyright (c) 2020 Evgeny Poberezkin\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\n\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\n\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tFormatRegistry.Set('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = parseDateTimeEmptySpace(value).replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tFormatRegistry.Set('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tFormatRegistry.Set(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tFormatRegistry.Set(formatName, formatValue)\n\t}\n})\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('integer'))\n\tFormatRegistry.Set(\n\t\t'integer',\n\t\t(value) => !!value && Number.isInteger(+value)\n\t)\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nif (!FormatRegistry.Has('ArrayString'))\n\tFormatRegistry.Set('ArrayString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n",
    "import {\n\tKind,\n\tTUnsafe,\n\tTypeRegistry,\n\tUnsafe,\n\ttype TAnySchema\n} from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { ElysiaFile } from '../universal/file'\nimport { InvalidFileType, ValidationError } from '../error'\nimport type { FileOptions, FileUnit } from './types'\nimport type { MaybeArray } from '../types'\n\nexport const tryParse = (v: unknown, schema: TAnySchema) => {\n\ttry {\n\t\treturn JSON.parse(v as string)\n\t} catch {\n\t\tthrow new ValidationError('property', schema, v)\n\t}\n}\n\nexport function createType<TSchema = unknown, TReturn = unknown>(\n\tkind: string,\n\tfunc: TypeRegistry.TypeRegistryValidationFunction<TSchema>\n): TUnsafe<TReturn> {\n\tif (!TypeRegistry.Has(kind)) TypeRegistry.Set<TSchema>(kind, func)\n\n\treturn ((options = {}) => Unsafe({ ...options, [Kind]: kind })) as any\n}\n\nexport const compile = <T extends TAnySchema>(schema: T) => {\n\ttry {\n\t\tconst compiler = TypeCompiler.Compile(schema) as TypeCheck<T> & {\n\t\t\tCreate(): T['static']\n\t\t\tError(v: unknown): asserts v is T['static']\n\t\t}\n\n\t\tcompiler.Create = () => Value.Create(schema)\n\t\tcompiler.Error = (v: unknown) =>\n\t\t\tnew ValidationError('property', schema, v, compiler.Errors(v))\n\n\t\treturn compiler\n\t} catch {\n\t\treturn {\n\t\t\tCheck: (v: unknown) => Value.Check(schema, v),\n\t\t\tCheckThrow: (v: unknown) => {\n\t\t\t\tif (!Value.Check(schema, v))\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'property',\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tv,\n\t\t\t\t\t\tValue.Errors(schema, v)\n\t\t\t\t\t)\n\t\t\t},\n\t\t\tDecode: (v: unknown) => Value.Decode(schema, v),\n\t\t\tCreate: () => Value.Create(schema),\n\t\t\tError: (v: unknown) =>\n\t\t\t\tnew ValidationError(\n\t\t\t\t\t'property',\n\t\t\t\t\tschema,\n\t\t\t\t\tv,\n\t\t\t\t\tValue.Errors(schema, v)\n\t\t\t\t)\n\t\t}\n\t}\n}\n\nexport const parseFileUnit = (size: FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nexport const checkFileExtension = (type: string, extension: string) => {\n\tif (type.startsWith(extension)) return true\n\n\treturn (\n\t\textension.charCodeAt(extension.length - 1) === 42 &&\n\t\textension.charCodeAt(extension.length - 2) === 47 &&\n\t\ttype.startsWith(extension.slice(0, -1))\n\t)\n}\n\nlet _fileTypeFromBlobWarn = false\nconst warnIfFileTypeIsNotInstalled = () => {\n\tif (!_fileTypeFromBlobWarn) {\n\t\tconsole.warn(\n\t\t\t\"[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension.\"\n\t\t)\n\t\t_fileTypeFromBlobWarn = true\n\t}\n}\n\nexport const loadFileType = async () =>\n\timport('file-type')\n\t\t.then((x) => {\n\t\t\t_fileTypeFromBlob = x.fileTypeFromBlob\n\t\t\treturn _fileTypeFromBlob\n\t\t})\n\t\t.catch(warnIfFileTypeIsNotInstalled)\n\nlet _fileTypeFromBlob: Function\nexport const fileTypeFromBlob = (file: Blob | File) => {\n\tif (_fileTypeFromBlob) return _fileTypeFromBlob(file)\n\n\treturn loadFileType().then((mod) => {\n\t\tif (mod) return mod(file)\n\t})\n}\n\nexport const validateFileExtension = async (\n\tfile: MaybeArray<Blob | File | undefined>,\n\textension: string | string[],\n\t// @ts-ignore\n\tname = file?.name ?? ''\n): Promise<boolean> => {\n\tif (Array.isArray(file)) {\n\t\tawait Promise.all(\n\t\t\tfile.map((f) => validateFileExtension(f, extension, name))\n\t\t)\n\n\t\treturn true\n\t}\n\n\tif (!file) return false\n\n\tconst result = await fileTypeFromBlob(file)\n\tif (!result) throw new InvalidFileType(name, extension)\n\n\tif (typeof extension === 'string')\n\t\tif (!checkFileExtension(result.mime, extension))\n\t\t\tthrow new InvalidFileType(name, extension)\n\n\tfor (let i = 0; i < extension.length; i++)\n\t\tif (checkFileExtension(result.mime, extension[i])) return true\n\n\tthrow new InvalidFileType(name, extension)\n}\n\nexport const validateFile = (options: FileOptions, value: any) => {\n\tif (value instanceof ElysiaFile) return true\n\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\t// This only check file extension based on it's name / mimetype\n\t// to actual check the file type, use `validateFileExtension` instead\n\tif (options.extension) {\n\t\tif (typeof options.extension === 'string')\n\t\t\treturn checkFileExtension(value.type, options.extension)\n\n\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\tif (checkFileExtension(value.type, options.extension[i]))\n\t\t\t\treturn true\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n",
    "// @ts-ignore\nexport const isBun = typeof Bun !== 'undefined'\n// @ts-ignore\nexport const isDeno = typeof Deno !== 'undefined'\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport { type createReadStream as CreateReadStream } from 'fs'\nimport { type stat as Stat } from 'fs/promises'\n\nimport { isBun } from './utils'\nimport type { BunFile } from 'bun'\nimport type { MaybePromise } from '../types'\n\nexport const mime = {\n\taac: 'audio/aac',\n\tabw: 'application/x-abiword',\n\tai: 'application/postscript',\n\tarc: 'application/octet-stream',\n\tavi: 'video/x-msvideo',\n\tazw: 'application/vnd.amazon.ebook',\n\tbin: 'application/octet-stream',\n\tbz: 'application/x-bzip',\n\tbz2: 'application/x-bzip2',\n\tcsh: 'application/x-csh',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdll: 'application/octet-stream',\n\teot: 'application/vnd.ms-fontobject',\n\tepub: 'application/epub+zip',\n\tgif: 'image/gif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tjar: 'application/java-archive',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'application/javascript',\n\tjson: 'application/json',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmp2: 'audio/mpeg',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpa: 'video/mpeg',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpkg: 'application/vnd.apple.installer+xml',\n\todp: 'application/vnd.oasis.opendocument.presentation',\n\tods: 'application/vnd.oasis.opendocument.spreadsheet',\n\todt: 'application/vnd.oasis.opendocument.text',\n\toga: 'audio/ogg',\n\togv: 'video/ogg',\n\togx: 'application/ogg',\n\totf: 'font/otf',\n\tpng: 'image/png',\n\tpdf: 'application/pdf',\n\tppt: 'application/vnd.ms-powerpoint',\n\trar: 'application/x-rar-compressed',\n\trtf: 'application/rtf',\n\tsh: 'application/x-sh',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\tts: 'application/typescript',\n\tttf: 'font/ttf',\n\ttxt: 'text/plain',\n\tvsd: 'application/vnd.visio',\n\twav: 'audio/x-wav',\n\tweba: 'audio/webm',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'font/woff',\n\twoff2: 'font/woff2',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.ms-excel',\n\txlsx_OLD:\n\t\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txul: 'application/vnd.mozilla.xul+xml',\n\tzip: 'application/zip',\n\t'3gp': 'video/3gpp',\n\t'3gp_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp',\n\t'3gp2': 'video/3gpp2',\n\t'3gp2_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp2',\n\t'7z': 'application/x-7z-compressed'\n} as const\n\nexport const getFileExtension = (path: string) => {\n\tconst index = path.lastIndexOf('.')\n\tif (index === -1) return ''\n\n\treturn path.slice(index + 1)\n}\n\nexport const file = (path: string) => new ElysiaFile(path)\n\nlet createReadStream: typeof CreateReadStream\nlet stat: typeof Stat\n\nexport class ElysiaFile {\n\treadonly value: MaybePromise<unknown>\n\treadonly stats: ReturnType<typeof Stat> | undefined\n\n\tconstructor(public path: string) {\n\t\tif (isBun) this.value = Bun.file(path)\n\t\telse {\n\t\t\t// Browser\n\t\t\t// @ts-ignore\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tconsole.warn('Browser environment does not support file')\n\t\t\t} else {\n\t\t\t\tif (!createReadStream || !stat) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.value = import('fs').then((fs) => {\n\t\t\t\t\t\t\tcreateReadStream = fs.createReadStream\n\n\t\t\t\t\t\t\treturn fs.createReadStream(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.stats = import('fs/promises').then((fs) => {\n\t\t\t\t\t\t\tstat = fs.stat\n\n\t\t\t\t\t\t\treturn fs.stat(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// not empty\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.value = createReadStream(path)\n\t\t\t\t\tthis.stats = stat(path)!\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn (\n\t\t\t// @ts-ignore\n\t\t\tmime[getFileExtension(this.path)] || 'application/octet-stream'\n\t\t)\n\t}\n\n\tget length() {\n\t\tif (isBun) return (this.value as BunFile).size\n\n\t\treturn this.stats?.then((x) => x.size) ?? 0\n\t}\n}\n",
    "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type {\n\tTypeCheck,\n\tValueError,\n\tValueErrorIterator\n} from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\nimport type { ElysiaTypeCheck } from './schema'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t\t? process?.env\n\t\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport type ERROR_CODE = typeof ERROR_CODE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport class ElysiaCustomStatusResponse<\n\tconst in out Code extends number | keyof StatusMap,\n\tconst in out T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst in out Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n> {\n\tcode: Status\n\tresponse: T\n\n\tconstructor(code: Code, response: T) {\n\t\tconst res =\n\t\t\tresponse ??\n\t\t\t(code in InvertedStatusMap\n\t\t\t\t? // @ts-expect-error Always correct\n\t\t\t\t\tInvertedStatusMap[code]\n\t\t\t\t: code)\n\n\t\t// @ts-ignore Trust me bro\n\t\tthis.code = StatusMap[code] ?? code\n\t\tthis.response = res\n\t}\n}\n\nexport const status = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code\n>(\n\tcode: Code,\n\tresponse?: T\n) => new ElysiaCustomStatusResponse<Code, T>(code, response as any)\n\n/**\n * @deprecated use `Elysia.status` instead\n */\nexport const error = status\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor(cause?: Error) {\n\t\tsuper('Bad Request', {\n\t\t\tcause\n\t\t})\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic key: string,\n\t\tmessage?: string\n\t) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport const mapValueError = (error: ValueError | undefined) => {\n\tif (!error)\n\t\treturn {\n\t\t\tsummary: undefined\n\t\t}\n\n\tconst { message, path, value, type } = error\n\n\tconst property = path.slice(1).replaceAll('/', '.')\n\tconst isRoot = path === ''\n\n\tswitch (type) {\n\t\tcase 42:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should not be provided`\n\t\t\t\t\t: `Property '${property}' should not be provided`\n\t\t\t}\n\n\t\tcase 45:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value is missing`\n\t\t\t\t\t: `Property '${property}' is missing`\n\t\t\t}\n\n\t\tcase 50:\n\t\t\t// Expected string to match 'email' format\n\t\t\tconst quoteIndex = message.indexOf(\"'\")!\n\t\t\tconst format = message.slice(\n\t\t\t\tquoteIndex + 1,\n\t\t\t\tmessage.indexOf(\"'\", quoteIndex + 1)\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be an email`\n\t\t\t\t\t: `Property '${property}' should be ${format}`\n\t\t\t}\n\n\t\tcase 54:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: `${message\n\t\t\t\t\t.slice(0, 9)\n\t\t\t\t\t.trim()} property '${property}' to be ${message\n\t\t\t\t\t.slice(8)\n\t\t\t\t\t.trim()} but found: ${value}`\n\t\t\t}\n\n\t\tcase 62:\n\t\t\tconst union = error.schema.anyOf\n\t\t\t\t.map((x: Record<string, unknown>) => `'${x?.format ?? x.type}'`)\n\t\t\t\t.join(', ')\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be one of ${union}`\n\t\t\t\t\t: `Property '${property}' should be one of: ${union}`\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn { summary: message, ...error }\n\t}\n}\n\nexport class InvalidFileType extends Error {\n\tcode = 'INVALID_FILE_TYPE'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic property: string,\n\t\tpublic expected: string | string[],\n\t\tpublic message = `\"${property}\" has invalid file type`\n\t) {\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, InvalidFileType.prototype)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\tif (isProduction)\n\t\t\treturn new Response(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: 'body'\n\t\t\t\t}),\n\t\t\t\t{\n\t\t\t\t\tstatus: 422,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...headers,\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: 'body',\n\t\t\t\tsummary: 'Invalid file type',\n\t\t\t\tmessage: this.message,\n\t\t\t\tproperty: this.property,\n\t\t\t\texpected: this.expected\n\t\t\t}),\n\t\t\t{\n\t\t\t\tstatus: 422,\n\t\t\t\theaders: {\n\t\t\t\t\t...headers,\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any> | ElysiaTypeCheck<any>,\n\t\tpublic value: unknown,\n\t\terrors?: ValueErrorIterator\n\t) {\n\t\tif (\n\t\t\tvalue &&\n\t\t\ttypeof value === 'object' &&\n\t\t\tvalue instanceof ElysiaCustomStatusResponse\n\t\t)\n\t\t\tvalue = value.response\n\n\t\tconst error =\n\t\t\terrors?.First() ||\n\t\t\t(isProduction\n\t\t\t\t? undefined\n\t\t\t\t: 'Errors' in validator\n\t\t\t\t\t? validator.Errors(value).First()\n\t\t\t\t\t: Value.Errors(validator, value).First())\n\n\t\tconst customError =\n\t\t\terror?.schema?.message || error?.schema?.error !== undefined\n\t\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t\t? error.schema.error({\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tget errors() {\n\t\t\t\t\t\t\t\treturn [...validator.Errors(value)].map(\n\t\t\t\t\t\t\t\t\tmapValueError\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t: error.schema.error\n\t\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError !== undefined) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)].map(mapValueError)\n\t\t\t\t\t: [...Value.Errors(validator, value)].map(mapValueError)\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn 'Errors' in this.validator\n\t\t\t? [...this.validator.Errors(this.value)].map(mapValueError)\n\t\t\t: // @ts-ignore\n\t\t\t\t[...Value.Errors(this.validator, this.value)].map(mapValueError)\n\t}\n\n\tstatic simplifyModel(\n\t\tvalidator: TSchema | TypeCheck<any> | ElysiaTypeCheck<any>\n\t) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "import type { Sucrose } from './sucrose'\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tLifeCycleStore,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tMapResponse,\n\tErrorHandler,\n\tReplace,\n\tAfterResponseHandler,\n\tSchemaValidator,\n\tAnyLocalHook,\n\tSSEPayload\n} from './types'\nimport { ElysiaFile } from './universal/file'\n\nexport const hasHeaderShorthand = 'toJSON' in new Headers()\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nexport const isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle Object.create(null)\n\t(v.toString &&\n\t\t// Handle import * as Sentry from '@sentry/bun'\n\t\t// This also handle [object Date], [object Array]\n\t\t// and FFI value like [object Prisma]\n\t\tv.toString().startsWith('[object ') &&\n\t\tv.toString() !== '[object Object]') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\toptions?: {\n\t\tskipKeys?: string[]\n\t\toverride?: boolean\n\t}\n): A & B => {\n\tconst skipKeys = options?.skipKeys\n\tconst override = options?.override ?? true\n\n\tif (!isObject(target) || !isObject(source)) return target as A & B\n\n\tfor (const [key, value] of Object.entries(source)) {\n\t\tif (skipKeys?.includes(key)) continue\n\n\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\tif (override || !(key in target))\n\t\t\t\ttarget[key as keyof typeof target] = value\n\n\t\t\tcontinue\n\t\t}\n\n\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t(target as any)[key] as any,\n\t\t\tvalue,\n\t\t\t{ skipKeys, override }\n\t\t)\n\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\tconst v = mergeDeep(Object.assign({}, a), b, {\n\t\tskipKeys: ['properties']\n\t}) as A & B\n\n\t// @ts-expect-error\n\tif (v.properties) delete v.properties\n\n\treturn v\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] | undefined,\n\tb: T | T[] | undefined\n): T[] | undefined => {\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (a) {\n\t\tif (!Array.isArray(a)) a = [a]\n\t\tfor (const item of a) {\n\t\t\tarray.push(item)\n\n\t\t\tif (item.checksum) checksums.push(item.checksum)\n\t\t}\n\t}\n\n\tif (b) {\n\t\tif (!Array.isArray(b)) b = [b]\n\t\tfor (const item of b)\n\t\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\t}\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'mapResponse',\n\t'afterResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b)) return Object.assign(a, b)\n\telse if (a && !isRecordNumber(a) && isRecordNumber(b))\n\t\treturn Object.assign({ 200: a }, b)\n\n\treturn b ?? a\n}\n\nexport const mergeSchemaValidator = (\n\ta?: SchemaValidator | null,\n\tb?: SchemaValidator | null\n): SchemaValidator => {\n\tif (!a && !b)\n\t\treturn {\n\t\t\tbody: undefined,\n\t\t\theaders: undefined,\n\t\t\tparams: undefined,\n\t\t\tquery: undefined,\n\t\t\tcookie: undefined,\n\t\t\tresponse: undefined\n\t\t}\n\n\treturn {\n\t\tbody: b?.body ?? a?.body,\n\t\theaders: b?.headers ?? a?.headers,\n\t\tparams: b?.params ?? a?.params,\n\t\tquery: b?.query ?? a?.query,\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// @ts-ignore ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t)\n\t}\n}\n\nexport const mergeHook = (\n\ta?: Partial<LifeCycleStore>,\n\tb?: AnyLocalHook\n\t// { allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\tif (!Object.values(b).find((x) => x !== undefined && x !== null))\n\t\treturn { ...a } as any\n\n\tconst hook = {\n\t\t...a,\n\t\t...b,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\t// @ts-ignore\n\t\t\t\tfnToContainer(a?.resolve, 'resolve'),\n\t\t\t\ta?.beforeHandle\n\t\t\t),\n\t\t\tmergeObjectArray(\n\t\t\t\tfnToContainer(b.resolve, 'resolve'),\n\t\t\t\tb?.beforeHandle\n\t\t\t)\n\t\t),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta?.afterResponse,\n\t\t\tb?.afterResponse\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n\n\tif (hook.resolve) delete hook.resolve\n\n\treturn hook\n}\n\nexport const lifeCycleToArray = (a: LifeCycleStore) => {\n\tif (a.parse && !Array.isArray(a.parse)) a.parse = [a.parse]\n\n\tif (a.transform && !Array.isArray(a.transform)) a.transform = [a.transform]\n\n\tif (a.afterHandle && !Array.isArray(a.afterHandle))\n\t\ta.afterHandle = [a.afterHandle]\n\n\tif (a.mapResponse && !Array.isArray(a.mapResponse))\n\t\ta.mapResponse = [a.mapResponse]\n\n\tif (a.afterResponse && !Array.isArray(a.afterResponse))\n\t\ta.afterResponse = [a.afterResponse]\n\n\tif (a.trace && !Array.isArray(a.trace)) a.trace = [a.trace]\n\tif (a.error && !Array.isArray(a.error)) a.error = [a.error]\n\n\tlet beforeHandle = []\n\n\t// @ts-expect-error\n\tif (a.resolve) {\n\t\tbeforeHandle = fnToContainer(\n\t\t\t// @ts-expect-error\n\t\t\tArray.isArray(a.resolve) ? a.resolve : [a.resolve],\n\t\t\t'resolve'\n\t\t) as any[]\n\n\t\t// @ts-expect-error\n\t\tdelete a.resolve\n\t}\n\n\tif (a.beforeHandle) {\n\t\tif (beforeHandle.length)\n\t\t\tbeforeHandle = beforeHandle.concat(\n\t\t\t\tArray.isArray(a.beforeHandle)\n\t\t\t\t\t? a.beforeHandle\n\t\t\t\t\t: [a.beforeHandle]\n\t\t\t)\n\t\telse\n\t\t\tbeforeHandle = Array.isArray(a.beforeHandle)\n\t\t\t\t? a.beforeHandle\n\t\t\t\t: [a.beforeHandle]\n\t}\n\n\tif (beforeHandle.length) a.beforeHandle = beforeHandle\n\n\treturn a\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasBunHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nexport const injectChecksum = (\n\tchecksum: number | undefined,\n\tx: MaybeArray<HookContainer> | undefined\n) => {\n\tif (!x) return\n\n\tif (!Array.isArray(x)) {\n\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\tconst fn = x\n\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\treturn fn\n\t}\n\n\t// ? clone fns is required to prevent side-effect from changing hookType\n\tconst fns = [...x]\n\n\tfor (const fn of fns) {\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t}\n\n\treturn fns\n}\n\nexport const mergeLifeCycle = (\n\ta: Partial<LifeCycleStore>,\n\tb: Partial<LifeCycleStore | AnyLocalHook>,\n\tchecksum?: number\n): LifeCycleStore => {\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(checksum, b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(checksum, b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(checksum, b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(checksum, b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\t// @ts-ignore\n\t\t\t\tfnToContainer(a.resolve, 'resolve'),\n\t\t\t\ta.beforeHandle\n\t\t\t),\n\t\t\tinjectChecksum(\n\t\t\t\tchecksum,\n\t\t\t\tmergeObjectArray(\n\t\t\t\t\tfnToContainer(b?.resolve, 'resolve'),\n\t\t\t\t\tb?.beforeHandle\n\t\t\t\t)\n\t\t\t)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(checksum, b?.afterHandle)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(checksum, b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta.afterResponse,\n\t\t\tinjectChecksum(checksum, b?.afterResponse)\n\t\t) as HookContainer<AfterResponseHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: mergeObjectArray(\n\t\t\ta.trace,\n\t\t\tinjectChecksum(checksum, b?.trace)\n\t\t) as HookContainer<TraceHandler<any, any>>[],\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(checksum, b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(checksum, b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean }\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (hook: AnyLocalHook): AnyLocalHook => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tmapResponse: filterGlobal(hook?.mapResponse),\n\t\tafterResponse: filterGlobal(hook?.afterResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\ttrace: filterGlobal(hook?.trace)\n\t}\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\n\twhile (trimmedDigest.endsWith('='))\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\t// console.log({\n\t// \tval,\n\t// \tsecret,\n\t// \thash: removeTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t// })\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>,\n\tmanage: ReturnType<typeof createMacroManager>\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (primitiveHookMap[key] || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tconst hook = v(value)\n\n\t\t\tif (typeof hook === 'object')\n\t\t\t\tfor (const [k, v] of Object.entries(hook))\n\t\t\t\t\tmanage(k as keyof LifeCycleStore)({\n\t\t\t\t\t\tfn: v as any\n\t\t\t\t\t})\n\t\t}\n\n\t\tdelete property[key as unknown as keyof typeof extension]\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: Partial<LifeCycleStore>\n\t\tlocalHook: Partial<AnyLocalHook>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\t// @ts-expect-error this is available in macro v2\n\t\tif (stackName === 'resolve') {\n\t\t\ttype = {\n\t\t\t\t...type,\n\t\t\t\tsubType: 'resolve'\n\t\t\t}\n\t\t}\n\n\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\tif (typeof localHook[stackName] === 'function')\n\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\t\tif (!Array.isArray(localHook[stackName]))\n\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).c