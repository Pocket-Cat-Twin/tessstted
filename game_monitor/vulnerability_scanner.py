"""
Security Vulnerability Scanner for Game Monitor System

Automated security assessment and vulnerability detection
to identify potential security weaknesses and configuration issues.
"""

import os
import subprocess
import hashlib
import time
import threading
from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
import logging
import json
import socket

from .advanced_logger import get_logger
from .error_handler import get_error_handler, ErrorContext, ErrorCategory, RecoveryStrategy
from .security_auditor import get_security_auditor
from .file_security import get_file_security_manager
from .constants import FileSystem

logger = get_logger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities that can be detected"""
    WEAK_PERMISSIONS = "weak_permissions"
    INSECURE_CONFIG = "insecure_config"
    OUTDATED_DEPENDENCIES = "outdated_dependencies"
    WEAK_PASSWORDS = "weak_passwords"
    OPEN_PORTS = "open_ports"
    MISSING_ENCRYPTION = "missing_encryption"
    UNSAFE_PATHS = "unsafe_paths"
    LOGGING_ISSUES = "logging_issues"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    SQL_INJECTION = "sql_injection"
    XSS_VULNERABILITIES = "xss_vulnerabilities"
    PRIVILEGE_ESCALATION = "privilege_escalation"


class SeverityLevel(Enum):
    """Severity levels for vulnerabilities"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class VulnerabilityFinding:
    """Individual vulnerability finding"""
    finding_id: str
    vulnerability_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    location: str  # File path, function name, etc.
    evidence: Dict[str, Any]
    cvss_score: Optional[float]
    cve_ids: List[str]
    remediation: str
    detected_at: float
    false_positive: bool = False


@dataclass
class ScanResult:
    """Results of a vulnerability scan"""
    scan_id: str
    scan_type: str
    started_at: float
    completed_at: float
    duration_seconds: float
    findings: List[VulnerabilityFinding]
    statistics: Dict[str, int]
    scan_coverage: Dict[str, bool]
    scan_errors: List[str]


class VulnerabilityScanner:
    """Comprehensive security vulnerability scanner"""
    
    def __init__(self):
        self.error_handler = get_error_handler()
        self.security_auditor = get_security_auditor()
        self.file_security = get_file_security_manager()
        
        # Scan configuration
        self.scan_enabled = True
        self.deep_scan_enabled = True
        self.network_scan_enabled = False  # Disabled by default
        
        # Vulnerability database
        self.known_vulnerabilities = self._load_vulnerability_database()
        self.scan_results = []
        
        # Scan modules
        self.scan_modules = {
            'file_permissions': self._scan_file_permissions,
            'configuration': self._scan_configuration_security,
            'dependencies': self._scan_dependencies,
            'network': self._scan_network_security,
            'code_analysis': self._scan_code_vulnerabilities,
            'authentication': self._scan_authentication_security,
            'encryption': self._scan_encryption_usage,
            'logging': self._scan_logging_security
        }
        
        # Statistics
        self.scan_stats = {
            'scans_performed': 0,
            'vulnerabilities_found': 0,
            'high_severity_count': 0,
            'critical_severity_count': 0,
            'false_positives': 0
        }
        
        self._lock = threading.Lock()
        
        logger.info("VulnerabilityScanner initialized with comprehensive security checks")
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """Load vulnerability patterns and signatures"""
        return {
            'weak_passwords': [
                'password', '123456', 'admin', 'root', 'guest', 
                'default', 'changeme', 'secret', 'test'
            ],
            'dangerous_functions': [
                'eval', 'exec', 'system', 'shell_exec', 'passthru',
                'subprocess.call', 'os.system', 'popen'
            ],
            'sql_patterns': [
                'SELECT.*FROM.*WHERE.*=.*',
                'INSERT.*INTO.*VALUES',
                'DELETE.*FROM.*WHERE',
                'UPDATE.*SET.*WHERE',
                'DROP.*TABLE',
                'CREATE.*TABLE'
            ],
            'file_inclusion_patterns': [
                'include.*\\$_',
                'require.*\\$_',
                'file_get_contents.*\\$_',
                'fopen.*\\$_'
            ],
            'insecure_configs': {
                'debug': ['DEBUG = True', 'debug: true', 'debug=1'],
                'secrets_exposed': ['password =', 'secret =', 'key =', 'token ='],
                'weak_encryption': ['md5', 'sha1', 'des', 'rc4']
            }
        }
    
    def run_comprehensive_scan(self, scan_type: str = "full") -> ScanResult:
        """Run comprehensive vulnerability scan"""
        scan_start = time.time()
        scan_id = f"SCAN_{int(scan_start)}_{hash(scan_type) % 10000}"
        
        findings = []
        scan_errors = []
        scan_coverage = {}
        
        try:
            logger.info(f"Starting comprehensive security scan: {scan_id}")
            
            # Run enabled scan modules
            for module_name, scan_function in self.scan_modules.items():
                if not self._should_run_module(module_name, scan_type):
                    scan_coverage[module_name] = False
                    continue
                
                try:
                    module_findings = scan_function()
                    findings.extend(module_findings)
                    scan_coverage[module_name] = True
                    
                    logger.debug(f"Scan module '{module_name}' found {len(module_findings)} issues")
                    
                except Exception as e:
                    scan_errors.append(f"Module '{module_name}' failed: {str(e)}")
                    scan_coverage[module_name] = False
                    logger.error(f"Scan module '{module_name}' failed: {e}")
            
            # Calculate statistics
            scan_completed = time.time()
            duration = scan_completed - scan_start
            
            statistics = self._calculate_scan_statistics(findings)
            
            # Create scan result
            scan_result = ScanResult(
                scan_id=scan_id,
                scan_type=scan_type,
                started_at=scan_start,
                completed_at=scan_completed,
                duration_seconds=duration,
                findings=findings,
                statistics=statistics,
                scan_coverage=scan_coverage,
                scan_errors=scan_errors
            )
            
            # Store scan result
            with self._lock:
                self.scan_results.append(scan_result)
                self.scan_stats['scans_performed'] += 1
                self.scan_stats['vulnerabilities_found'] += len(findings)
                self.scan_stats['high_severity_count'] += statistics.get('high_severity', 0)
                self.scan_stats['critical_severity_count'] += statistics.get('critical_severity', 0)
            
            # Log security event
            self.security_auditor.log_security_event(
                event_type="VULNERABILITY_SCAN",
                severity="INFO" if not findings else "MEDIUM",
                user_id="system",
                resource="vulnerability_scanner",
                action="comprehensive_scan",
                outcome="COMPLETED",
                details={
                    'scan_id': scan_id,
                    'findings_count': len(findings),
                    'duration_seconds': duration,
                    'high_severity': statistics.get('high_severity', 0),
                    'critical_severity': statistics.get('critical_severity', 0)
                }
            )
            
            logger.info(f"Security scan completed: {len(findings)} findings in {duration:.2f}s")
            return scan_result
            
        except Exception as e:
            error_context = ErrorContext(
                component="vulnerability_scanner",
                operation="run_comprehensive_scan",
                user_data={'scan_type': scan_type},
                system_state={'scan_enabled': self.scan_enabled},
                timestamp=datetime.now()
            )
            
            self.error_handler.handle_error(e, error_context, RecoveryStrategy.SKIP)
            logger.error(f"Vulnerability scan failed: {e}")
            
            # Return partial results
            return ScanResult(
                scan_id=scan_id,
                scan_type=scan_type,
                started_at=scan_start,
                completed_at=time.time(),
                duration_seconds=time.time() - scan_start,
                findings=findings,
                statistics=self._calculate_scan_statistics(findings),
                scan_coverage=scan_coverage,
                scan_errors=[str(e)]
            )
    
    def _should_run_module(self, module_name: str, scan_type: str) -> bool:
        """Determine if scan module should run"""
        if not self.scan_enabled:
            return False
        
        if module_name == 'network' and not self.network_scan_enabled:
            return False
        
        if scan_type == "quick" and module_name in ['dependencies', 'code_analysis']:
            return False
        
        return True
    
    def _scan_file_permissions(self) -> List[VulnerabilityFinding]:
        """Scan for insecure file permissions"""
        findings = []
        
        try:
            # Check critical directories and files
            critical_paths = [
                'config/',
                'data/',
                'logs/',
                FileSystem.DEFAULT_DB_PATH,
                FileSystem.CONFIG_FILE_PATH
            ]
            
            for path_str in critical_paths:
                path = Path(path_str)
                if not path.exists():
                    continue
                
                try:
                    stat_info = path.stat()
                    permissions = oct(stat_info.st_mode)[-3:]
                    
                    # Check for overly permissive permissions
                    if path.is_dir():
                        # Directories should not be world-writable
                        if permissions.endswith('7') or permissions.endswith('6'):
                            findings.append(VulnerabilityFinding(
                                finding_id=f"PERM_{hash(str(path))}",
                                vulnerability_type=VulnerabilityType.WEAK_PERMISSIONS,
                                severity=SeverityLevel.MEDIUM,
                                title=f"Directory has overly permissive permissions",
                                description=f"Directory {path} has permissions {permissions} which may allow unauthorized access",
                                location=str(path),
                                evidence={'permissions': permissions, 'type': 'directory'},
                                cvss_score=5.3,
                                cve_ids=[],
                                remediation=f"Change directory permissions to 750 or more restrictive",
                                detected_at=time.time()
                            ))
                    else:
                        # Files should not be world-readable/writable for sensitive data
                        if path.name.endswith(('.db', '.log', '.key')) and (
                            permissions.endswith('4') or permissions.endswith('6') or 
                            permissions.endswith('7')
                        ):
                            findings.append(VulnerabilityFinding(
                                finding_id=f"PERM_{hash(str(path))}",
                                vulnerability_type=VulnerabilityType.WEAK_PERMISSIONS,
                                severity=SeverityLevel.HIGH,
                                title=f"Sensitive file has weak permissions",
                                description=f"Sensitive file {path} has permissions {permissions} which may expose data",
                                location=str(path),
                                evidence={'permissions': permissions, 'type': 'file'},
                                cvss_score=7.5,
                                cve_ids=[],
                                remediation=f"Change file permissions to 600 or more restrictive",
                                detected_at=time.time()
                            ))
                
                except Exception as e:
                    logger.warning(f"Failed to check permissions for {path}: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"File permissions scan failed: {e}")
        
        return findings
    
    def _scan_configuration_security(self) -> List[VulnerabilityFinding]:
        """Scan configuration files for security issues"""
        findings = []
        
        try:
            config_files = [
                'config/config.yaml',
                'config.yaml',
                '.env',
                'settings.py',
                'config.json'
            ]
            
            for config_file in config_files:
                path = Path(config_file)
                if not path.exists():
                    continue
                
                try:
                    content = path.read_text(encoding='utf-8')
                    
                    # Check for exposed secrets
                    for pattern in self.known_vulnerabilities['insecure_configs']['secrets_exposed']:
                        if pattern.lower() in content.lower():
                            findings.append(VulnerabilityFinding(
                                finding_id=f"CONFIG_{hash(config_file)}_{hash(pattern)}",
                                vulnerability_type=VulnerabilityType.INSECURE_CONFIG,
                                severity=SeverityLevel.HIGH,
                                title="Potential secret exposure in configuration",
                                description=f"Configuration file {config_file} may contain exposed secrets",
                                location=config_file,
                                evidence={'pattern': pattern, 'file': config_file},
                                cvss_score=8.2,
                                cve_ids=[],
                                remediation="Move secrets to environment variables or encrypted storage",
                                detected_at=time.time()
                            ))
                    
                    # Check for debug settings
                    for debug_pattern in self.known_vulnerabilities['insecure_configs']['debug']:
                        if debug_pattern.lower() in content.lower():
                            findings.append(VulnerabilityFinding(
                                finding_id=f"DEBUG_{hash(config_file)}",
                                vulnerability_type=VulnerabilityType.INSECURE_CONFIG,
                                severity=SeverityLevel.MEDIUM,
                                title="Debug mode enabled in configuration",
                                description=f"Debug mode appears to be enabled in {config_file}",
                                location=config_file,
                                evidence={'debug_setting': True, 'file': config_file},
                                cvss_score=4.3,
                                cve_ids=[],
                                remediation="Disable debug mode in production",
                                detected_at=time.time()
                            ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan config file {config_file}: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Configuration security scan failed: {e}")
        
        return findings
    
    def _scan_dependencies(self) -> List[VulnerabilityFinding]:
        """Scan for vulnerable dependencies"""
        findings = []
        
        try:
            # Check requirements.txt for known vulnerable packages
            requirements_files = ['requirements.txt', 'setup.py', 'Pipfile', 'pyproject.toml']
            
            for req_file in requirements_files:
                path = Path(req_file)
                if not path.exists():
                    continue
                
                try:
                    content = path.read_text(encoding='utf-8')
                    
                    # Simple check for some commonly vulnerable packages
                    vulnerable_packages = [
                        'requests<2.20.0',  # Known vulnerabilities in older versions
                        'pyyaml<5.4.0',     # Known vulnerabilities
                        'pillow<8.1.1',     # Known vulnerabilities
                        'jinja2<2.11.3'     # Known vulnerabilities
                    ]
                    
                    for vuln_package in vulnerable_packages:
                        if vuln_package.split('<')[0] in content.lower():
                            findings.append(VulnerabilityFinding(
                                finding_id=f"DEP_{hash(vuln_package)}",
                                vulnerability_type=VulnerabilityType.OUTDATED_DEPENDENCIES,
                                severity=SeverityLevel.MEDIUM,
                                title=f"Potentially vulnerable dependency: {vuln_package.split('<')[0]}",
                                description=f"Package {vuln_package.split('<')[0]} may be vulnerable",
                                location=req_file,
                                evidence={'package': vuln_package, 'file': req_file},
                                cvss_score=6.1,
                                cve_ids=[],
                                remediation=f"Update {vuln_package.split('<')[0]} to latest version",
                                detected_at=time.time()
                            ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan dependencies in {req_file}: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Dependencies scan failed: {e}")
        
        return findings
    
    def _scan_network_security(self) -> List[VulnerabilityFinding]:
        """Scan for network security issues"""
        findings = []
        
        if not self.network_scan_enabled:
            return findings
        
        try:
            # Check for open ports (basic check)
            common_ports = [22, 23, 21, 80, 443, 3389, 5432, 3306, 6379, 27017]
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex(('localhost', port))
                    sock.close()
                    
                    if result == 0:  # Port is open
                        severity = SeverityLevel.LOW
                        if port in [23, 21]:  # Telnet, FTP
                            severity = SeverityLevel.HIGH
                        elif port in [22, 3389]:  # SSH, RDP
                            severity = SeverityLevel.MEDIUM
                        
                        findings.append(VulnerabilityFinding(
                            finding_id=f"PORT_{port}",
                            vulnerability_type=VulnerabilityType.OPEN_PORTS,
                            severity=severity,
                            title=f"Open port detected: {port}",
                            description=f"Port {port} is open and listening",
                            location=f"localhost:{port}",
                            evidence={'port': port, 'protocol': 'tcp'},
                            cvss_score=3.1 if severity == SeverityLevel.LOW else 7.5,
                            cve_ids=[],
                            remediation=f"Review if port {port} needs to be open, implement firewall rules",
                            detected_at=time.time()
                        ))
                
                except Exception:
                    continue  # Port scan failed, skip
        
        except Exception as e:
            logger.error(f"Network security scan failed: {e}")
        
        return findings
    
    def _scan_code_vulnerabilities(self) -> List[VulnerabilityFinding]:
        """Scan source code for security vulnerabilities"""
        findings = []
        
        try:
            # Scan Python files for dangerous functions
            python_files = list(Path('.').rglob('*.py'))
            
            for py_file in python_files:
                try:
                    content = py_file.read_text(encoding='utf-8')
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        line_lower = line.lower().strip()
                        
                        # Check for dangerous functions
                        for dangerous_func in self.known_vulnerabilities['dangerous_functions']:
                            if dangerous_func in line_lower and not line_lower.startswith('#'):
                                findings.append(VulnerabilityFinding(
                                    finding_id=f"CODE_{hash(str(py_file))}_{line_num}",
                                    vulnerability_type=VulnerabilityType.SQL_INJECTION,
                                    severity=SeverityLevel.HIGH,
                                    title=f"Dangerous function usage: {dangerous_func}",
                                    description=f"Potentially dangerous function '{dangerous_func}' used in {py_file}:{line_num}",
                                    location=f"{py_file}:{line_num}",
                                    evidence={'function': dangerous_func, 'line': line.strip()},
                                    cvss_score=8.8,
                                    cve_ids=[],
                                    remediation=f"Review usage of {dangerous_func} and implement proper input validation",
                                    detected_at=time.time()
                                ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan {py_file}: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Code vulnerability scan failed: {e}")
        
        return findings
    
    def _scan_authentication_security(self) -> List[VulnerabilityFinding]:
        """Scan for authentication security issues"""
        findings = []
        
        try:
            # This would integrate with the security manager to check for weak configurations
            # For now, basic checks
            
            # Check if default passwords might be in use
            config_files = list(Path('.').rglob('*.yaml')) + list(Path('.').rglob('*.json'))
            
            for config_file in config_files:
                try:
                    content = config_file.read_text(encoding='utf-8').lower()
                    
                    for weak_pass in self.known_vulnerabilities['weak_passwords']:
                        if weak_pass in content:
                            findings.append(VulnerabilityFinding(
                                finding_id=f"AUTH_{hash(str(config_file))}",
                                vulnerability_type=VulnerabilityType.WEAK_PASSWORDS,
                                severity=SeverityLevel.CRITICAL,
                                title="Weak password detected in configuration",
                                description=f"Weak password pattern found in {config_file}",
                                location=str(config_file),
                                evidence={'weak_password': True, 'file': str(config_file)},
                                cvss_score=9.8,
                                cve_ids=[],
                                remediation="Replace weak passwords with strong, randomly generated passwords",
                                detected_at=time.time()
                            ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan {config_file} for weak passwords: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Authentication security scan failed: {e}")
        
        return findings
    
    def _scan_encryption_usage(self) -> List[VulnerabilityFinding]:
        """Scan for missing or weak encryption"""
        findings = []
        
        try:
            # Check if encryption is properly implemented
            if not self.encryption_manager:
                findings.append(VulnerabilityFinding(
                    finding_id="ENC_MISSING",
                    vulnerability_type=VulnerabilityType.MISSING_ENCRYPTION,
                    severity=SeverityLevel.HIGH,
                    title="Encryption manager not available",
                    description="Encryption capabilities are not properly initialized",
                    location="system",
                    evidence={'encryption_available': False},
                    cvss_score=7.4,
                    cve_ids=[],
                    remediation="Install cryptography library and initialize encryption manager",
                    detected_at=time.time()
                ))
            
            # Check for weak encryption algorithms in code
            python_files = list(Path('.').rglob('*.py'))
            
            for py_file in python_files:
                try:
                    content = py_file.read_text(encoding='utf-8')
                    
                    for weak_crypto in self.known_vulnerabilities['insecure_configs']['weak_encryption']:
                        if weak_crypto in content.lower():
                            findings.append(VulnerabilityFinding(
                                finding_id=f"CRYPTO_{hash(str(py_file))}_{weak_crypto}",
                                vulnerability_type=VulnerabilityType.MISSING_ENCRYPTION,
                                severity=SeverityLevel.MEDIUM,
                                title=f"Weak cryptographic algorithm: {weak_crypto}",
                                description=f"Weak encryption algorithm '{weak_crypto}' found in {py_file}",
                                location=str(py_file),
                                evidence={'algorithm': weak_crypto, 'file': str(py_file)},
                                cvss_score=5.9,
                                cve_ids=[],
                                remediation=f"Replace {weak_crypto} with stronger algorithms like AES-256",
                                detected_at=time.time()
                            ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan {py_file} for weak encryption: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Encryption usage scan failed: {e}")
        
        return findings
    
    def _scan_logging_security(self) -> List[VulnerabilityFinding]:
        """Scan for logging security issues"""
        findings = []
        
        try:
            # Check if sensitive information might be logged
            python_files = list(Path('.').rglob('*.py'))
            
            for py_file in python_files:
                try:
                    content = py_file.read_text(encoding='utf-8')
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        line_lower = line.lower().strip()
                        
                        # Check for potential sensitive data logging
                        if ('log' in line_lower and any(sensitive in line_lower for sensitive in 
                            ['password', 'secret', 'key', 'token', 'credential'])):
                            if not line_lower.startswith('#'):  # Skip comments
                                findings.append(VulnerabilityFinding(
                                    finding_id=f"LOG_{hash(str(py_file))}_{line_num}",
                                    vulnerability_type=VulnerabilityType.LOGGING_ISSUES,
                                    severity=SeverityLevel.MEDIUM,
                                    title="Potential sensitive data logging",
                                    description=f"Possible sensitive data logging in {py_file}:{line_num}",
                                    location=f"{py_file}:{line_num}",
                                    evidence={'line': line.strip(), 'line_number': line_num},
                                    cvss_score=4.3,
                                    cve_ids=[],
                                    remediation="Review logging statement and avoid logging sensitive data",
                                    detected_at=time.time()
                                ))
                
                except Exception as e:
                    logger.warning(f"Failed to scan {py_file} for logging issues: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Logging security scan failed: {e}")
        
        return findings
    
    def _calculate_scan_statistics(self, findings: List[VulnerabilityFinding]) -> Dict[str, int]:
        """Calculate statistics from scan findings"""
        stats = {
            'total_findings': len(findings),
            'critical_severity': 0,
            'high_severity': 0,
            'medium_severity': 0,
            'low_severity': 0
        }
        
        # Count by vulnerability type
        vuln_types = {}
        
        for finding in findings:
            # Count by severity
            severity_key = f"{finding.severity.value}_severity"
            stats[severity_key] += 1
            
            # Count by type
            vuln_type = finding.vulnerability_type.value
            vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1
        
        stats.update(vuln_types)
        return stats
    
    def get_scan_results(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent scan results"""
        with self._lock:
            recent_scans = sorted(self.scan_results, key=lambda s: s.started_at, reverse=True)[:limit]
            return [asdict(scan) for scan in recent_scans]
    
    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get summary of all vulnerabilities"""
        if not self.scan_results:
            return {'error': 'No scan results available'}
        
        latest_scan = max(self.scan_results, key=lambda s: s.started_at)
        
        return {
            'latest_scan': {
                'scan_id': latest_scan.scan_id,
                'completed_at': latest_scan.completed_at,
                'total_findings': len(latest_scan.findings),
                'critical_findings': latest_scan.statistics.get('critical_severity', 0),
                'high_findings': latest_scan.statistics.get('high_severity', 0),
                'scan_coverage': latest_scan.scan_coverage
            },
            'overall_statistics': self.scan_stats,
            'top_vulnerability_types': self._get_top_vulnerability_types()
        }
    
    def _get_top_vulnerability_types(self) -> List[Tuple[str, int]]:
        """Get most common vulnerability types"""
        vuln_counts = {}
        
        for scan_result in self.scan_results:
            for finding in scan_result.findings:
                vuln_type = finding.vulnerability_type.value
                vuln_counts[vuln_type] = vuln_counts.get(vuln_type, 0) + 1
        
        return sorted(vuln_counts.items(), key=lambda x: x[1], reverse=True)[:5]


# Global vulnerability scanner instance
_vulnerability_scanner_instance = None
_scanner_lock = threading.Lock()

def get_vulnerability_scanner() -> VulnerabilityScanner:
    """Get singleton vulnerability scanner instance"""
    global _vulnerability_scanner_instance
    if _vulnerability_scanner_instance is None:
        with _scanner_lock:
            if _vulnerability_scanner_instance is None:
                _vulnerability_scanner_instance = VulnerabilityScanner()
    return _vulnerability_scanner_instance


# Convenience function
def run_security_scan(scan_type: str = "full") -> Dict[str, Any]:
    """Run security vulnerability scan"""
    scanner = get_vulnerability_scanner()
    result = scanner.run_comprehensive_scan(scan_type)
    return asdict(result)